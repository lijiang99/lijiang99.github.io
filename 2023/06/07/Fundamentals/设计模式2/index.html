<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="li jiang">





<title>设计模式（下篇） | bd7xzz</title>



    <link rel="icon" href="/favicon.jpg">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    


<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="bd7xzz" type="application/atom+xml">
</head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">设计模式（下篇）</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">li jiang</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">June 7, 2023&nbsp;&nbsp;0:00:00</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <span id="more"></span>

<h2 id="Decorator–装饰模式"><a href="#Decorator–装饰模式" class="headerlink" title="Decorator–装饰模式"></a><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Yr4y157Ci/?p=6&spm_id_from=pageDriver&vd_source=65122611208f4d2dd8e86fb48f5e4e28">Decorator–装饰模式</a></h2><ul>
<li><p>概念：动态（组合方式）地给一个对象增加一些额外的功能，比生成子类（继承方式）更加灵活，并能消除代码重复，以及减少子类个数。</p>
</li>
<li><p>实现：设计继承于接口类（抽象基类）的中间类，并且包含一个抽象基类的指针成员，即在接口上表现为<code>is-a</code>，而在实现上表现为<code>has-a</code>。最后通过继承中间类以完成对功能的统一扩展。</p>
</li>
<li><p>场景：设计IO库时，需在基础的流操作上增加一些额外操作（加密、缓冲），若每扩展一次操作都使用一次继承来实现，那么随着组合的增加，子类及其相关代码会变得极其臃肿，且代码中存在大量重复操作。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象基类，提供一些公共接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">char</span> <span class="title">read</span><span class="params">(<span class="type">int</span> num)</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">char</span> data)</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Stream</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件流</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileStream</span> : <span class="keyword">public</span> Stream &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">char</span> <span class="title">read</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">char</span> data)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网络流</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NetworkStream</span> : <span class="keyword">public</span> Stream &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">char</span> <span class="title">read</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">char</span> data)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在对流的加密扩展中，实际上加密操作是一致的，而过度使用继承则导致存在大量重复的加密代码。</span></span><br><span class="line"><span class="comment">// 不仅造成了代码的冗余，而且随着需求的变动，若要修改加密方式，则所有出现加密的地方都要进行更改。</span></span><br><span class="line"><span class="comment">// 扩展操作：对文件流加密</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CryptoFileStream</span> : <span class="keyword">public</span> FileStream &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">char</span> <span class="title">read</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 额外的加密操作...</span></span><br><span class="line">            FileStream::<span class="built_in">read</span>(num); <span class="comment">// 读文件流</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">char</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 额外的加密操作...</span></span><br><span class="line">            FileStream::<span class="built_in">write</span>(data); <span class="comment">// 写文件流</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展操作：对网络流加密</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CryptoNetworkStream</span> : <span class="keyword">public</span> NetworkStream &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">char</span> <span class="title">read</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 额外的加密操作...</span></span><br><span class="line">            NetworkStream::<span class="built_in">read</span>(num); <span class="comment">// 读网络流</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">char</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 额外的加密操作...</span></span><br><span class="line">            NetworkStream::<span class="built_in">write</span>(data); <span class="comment">// 写网络流</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展操作：对文件流缓冲</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferedFileStream</span> : <span class="keyword">public</span> FileStream &#123; ... &#125;;</span><br><span class="line"><span class="comment">// 扩展操作：对网络流缓冲</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferedNetworkStream</span> : <span class="keyword">public</span> NetworkStream &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>重构：定义一个中间类，继承于抽象基类，并声明一个抽象基类的指针（用于多态调用）作为类成员。通过继承中间类来完成操作的扩展，从而将原先的编译时装配转换为运行时装配。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象基类，提供一些公共接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">char</span> <span class="title">read</span><span class="params">(<span class="type">int</span> num)</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">char</span> data)</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Stream</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件流</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileStream</span> : <span class="keyword">public</span> Stream &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">char</span> <span class="title">read</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">char</span> data)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网络流</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NetworkStream</span> : <span class="keyword">public</span> Stream &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">char</span> <span class="title">read</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">char</span> data)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间类，继承Stream，并内含一个Stream的指针成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecoratorStream</span> : <span class="keyword">public</span> Stream &#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        Stream *stream; <span class="comment">// 由运行时完成绑定（文件流或网络流）</span></span><br><span class="line">        <span class="built_in">DecoratorStream</span>(Stream *stm) : <span class="built_in">stream</span>(stm) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展操作：对流加密的统一操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CryptoStream</span> : <span class="keyword">public</span> DecoratorStream &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">CryptoStream</span>(Stream *stm) : <span class="built_in">DecoratorStream</span>(stm) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">char</span> <span class="title">read</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 额外的加密操作...</span></span><br><span class="line">            stream-&gt;<span class="built_in">read</span>(num); <span class="comment">// 读文件流</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">char</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 额外的加密操作...</span></span><br><span class="line">            stream-&gt;<span class="built_in">write</span>(data); <span class="comment">// 写文件流</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展操作：对流缓冲的统一操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferedStream</span> : <span class="keyword">public</span> DecoratorStream &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Factory–工厂模式"><a href="#Factory–工厂模式" class="headerlink" title="Factory–工厂模式"></a><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Yr4y157Ci?p=8&vd_source=65122611208f4d2dd8e86fb48f5e4e28">Factory–工厂模式</a></h2><ul>
<li><p>概念：通过“对象创建”模式绕开<code>new</code>，以避免<code>new</code>过程中所导致的紧耦合（依赖具体类），实现对象创建的稳定。</p>
</li>
<li><p>实现：定义一个用于创建对象的接口，让子类决定实例化哪一个具体类，使得一个类的实例化延迟到子类。缺点在于要求对象创建时的参数相同。</p>
</li>
<li><p>场景：文件分割器对于不同类型的文件采取不同的分割算法，常规思路是定义一个抽象基类（面向接口编程），派生类继承该抽象基类并实现其中用于分割的虚函数。然后在需要进行文件分割时，用抽象基类指针（依赖抽象）指向具体的派生类对象（依赖细节，违反依赖倒置原则）以完成多态调用。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Splitter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">split</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Splitter</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 具体的文件文件分割器，实现不同的分割算法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TxtSplitter</span> : <span class="keyword">public</span> Splitter &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PictureSplitter</span> : <span class="keyword">public</span> Splitter &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoSplitter</span> : <span class="keyword">public</span> Splitter &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainForm</span> : <span class="keyword">public</span> Form &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">buttonClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 面向接口编程，利用抽象基类指针指向派生类对象</span></span><br><span class="line">            <span class="comment">// 此时对于等号左边来说，抽象基类指针已完成依赖抽象</span></span><br><span class="line">            <span class="comment">// 但等号右边是一个具体的派生类，依然是依赖细节，因此违反了依赖倒置原则</span></span><br><span class="line">            Splitter *splitter = <span class="keyword">new</span> <span class="built_in">TxtSplitter</span>();</span><br><span class="line">            splitter-&gt;<span class="built_in">split</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>重构：使用函数返回对象的方式绕开<code>new</code>来创建对象，具体实现是先创建一个工厂的抽象基类，再为每一个具体类都创建一个具体工厂（继承于工厂的抽象基类），并在具体工厂中重写创建函数（工厂的抽象基类中的纯虚函数）以创建对应的具体类（真正使用<code>new</code>的地方）。最后在需要创建对象时，将工厂的抽象基类声明为形参，并传递具体的工厂作为实参。从而实现将常规new操作转换为多态<code>new</code>，使得等号两边都符合依赖抽象。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Splitter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">split</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Splitter</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 具体类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TxtSplitter</span> : <span class="keyword">public</span> Splitter &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PictureSplitter</span> : <span class="keyword">public</span> Splitter &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoSplitter</span> : <span class="keyword">public</span> Splitter &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂的抽象基类，声明一个用于创建对象的接口（纯虚函数）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SplitterFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> Splitter* <span class="title">createSplitter</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">SplitterFactory</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 针对每一个具体类都创建一个具体工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TxtSplitterFactory</span> : <span class="keyword">public</span> SplitterFactory &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> Splitter* <span class="title">createSplitter</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TxtSplitter</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PictureSplitterFactory</span> : <span class="keyword">public</span> SplitterFactory &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> Splitter* <span class="title">createSplitter</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">PictureSplitter</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoSplitterFactory</span> : <span class="keyword">public</span> SplitterFactory &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> Splitter* <span class="title">createSplitter</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">VideoSplitter</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainForm</span> : <span class="keyword">public</span> Form &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        SplitterFactory *factory;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 传递一个具体的工厂作为参数给构造函数，来用于后续创建具体类的流程</span></span><br><span class="line">        <span class="built_in">MainForm</span>(SplitterFactory *factory) : <span class="built_in">factory</span>(factory) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">buttonClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 此时就将常规的new转换成了多态new，从而保证等号两边都依赖抽象</span></span><br><span class="line">            Splitter *splitter = factory-&gt;<span class="built_in">createSplitter</span>();</span><br><span class="line">            splitter-&gt;<span class="built_in">split</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Abstract-Factory–抽象工厂"><a href="#Abstract-Factory–抽象工厂" class="headerlink" title="Abstract Factory–抽象工厂"></a><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Yr4y157Ci/?p=9&spm_id_from=pageDriver&vd_source=65122611208f4d2dd8e86fb48f5e4e28">Abstract Factory–抽象工厂</a></h2><ul>
<li><p>概念：与简单工厂相同，都是绕过常规的对象创建方式（<code>new</code>）来完成对象创建，但主要解决的是“一系列相互依赖的对象”的创建工作，而非单个对象。</p>
</li>
<li><p>实现：提供一个接口，让其负责创建一系列相互依赖的对象，无需指定它们具体的类。</p>
</li>
<li><p>场景：数据访问层需创建一系列的对象，进行数据库连接、执行数据库命令等。若继续使用简单工厂模式，则需要为多个对象创建多个工厂。但这些对象之间都是相互依赖的，换句话说不同系列的对象不能搭配使用（不能用SQL Server的数据库连接去执行MySQL的命令）。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据库访问的接口类（抽象基类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DBConnection</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DBCommand</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// 支持MySQL</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySQLConnection</span> : <span class="keyword">public</span> DBConnection &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySQLCommand</span> : <span class="keyword">public</span> DBCommand &#123;&#125;;</span><br><span class="line"><span class="comment">// 支持SQL Server</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlServerConnection</span> : <span class="keyword">public</span> DBConnection &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlServerCommand</span> : <span class="keyword">public</span> DBCommand &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂的抽象基类，声明用于创建对象的接口（纯虚函数）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DBConnectionFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> DBConnection* <span class="title">createDBConnection</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DBCommandFatory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> DBCommand* <span class="title">createDBCommand</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 支持MySQL的具体工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySQLConnectionFactory</span> : <span class="keyword">public</span> DBConnectionFactory &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> DBConnection* <span class="title">createDBConnection</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySQLCommandFactory</span> : <span class="keyword">public</span> DBCommandFatory &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> DBCommand* <span class="title">createDBCommand</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 支持SQL Server的具体工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SQLServerConnectionFactory</span> : <span class="keyword">public</span> DBConnectionFactory &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> DBConnection* <span class="title">createDBConnection</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SQLServerCommandFactory</span> : <span class="keyword">public</span> DBCommandFatory &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> DBCommand* <span class="title">createDBCommand</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmployeDAO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        DBConnectionFactory* dbConnectionFactory;</span><br><span class="line">        DBCommandFatory* dbCommandFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">vector&lt;EmployeDAO&gt; <span class="title">GetEmployees</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            DBConnection* connection = dbConnectionFactory-&gt;<span class="built_in">createDBConnection</span>();</span><br><span class="line">            DBCommand* command = dbCommandFactory-&gt;<span class="built_in">createDBCommand</span>();</span><br><span class="line">            <span class="comment">// 此处表明具体的命令需要与对应的具体连接相关（二者相互依赖），不同系列的对象不能搭配使用</span></span><br><span class="line">            command-&gt;<span class="built_in">setConnection</span>(connection);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>重构：将同一系列的对象创建工作都交由一个工厂完成，而非多个工厂。不仅可以简化代码结构，使代码更加清晰优雅，还可以避免错误地搭配不同系列对象的情况。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> DBConnection* <span class="title">createDBConnection</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> DBCommand* <span class="title">createDBCommand</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySQLFactory</span> : <span class="keyword">public</span> DBFactory &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> DBConnection* <span class="title">createDBConnection</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> DBCommand* <span class="title">createDBCommand</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmployeDAO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        DBFactory* dbFactory;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">vector&lt;EmployeDAO&gt; <span class="title">GetEmployees</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            DBConnection* connection = dbFactory-&gt;<span class="built_in">createDBConnection</span>();</span><br><span class="line">            DBCommand* command = dbFactory-&gt;<span class="built_in">createDBCommand</span>();</span><br><span class="line">            <span class="comment">// 此时同一系列对象之间的关联性得到了保证</span></span><br><span class="line">            command-&gt;<span class="built_in">setConnection</span>(connection);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Proxy–代理模式"><a href="#Proxy–代理模式" class="headerlink" title="Proxy–代理模式"></a><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Yr4y157Ci?p=15&vd_source=65122611208f4d2dd8e86fb48f5e4e28">Proxy–代理模式</a></h2><ul>
<li>概念：在面向对象系统中，有些对象由于某种原因（如对象创建开销大、某些操作需要安全控制、或需要进程外的访问–分布式系统等）直接访问会给系统结构造成麻烦。因此需要增加一层间接层，以确保在不失去接口一致性的同时来控制对象特有的复杂性。</li>
</ul>
<div align="center" style=transform:scale(0.9)>
<img src="/images/代理模式.png"/>
</div>

<ul>
<li><p>实现：为其他对象提供一种代理以控制（隔离，使用接口）对这个对象的访问。</p>
</li>
<li><p>场景：直接访问式</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject</span>: <span class="keyword">public</span> Subject &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123; <span class="comment">// ... &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Subject *subject;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 这种方式可能因为上述内容中的某种原因，导致压根拿不到RealSubject</span></span><br><span class="line">        <span class="built_in">Client</span>() &#123; subject = <span class="keyword">new</span> <span class="built_in">RealSubject</span>(); <span class="comment">// ... &#125;</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">doTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// ...  </span></span><br><span class="line">            subject-&gt;<span class="built_in">process</span>();</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>重构：使用代理模式（分布式中大量应用），在某些平台常常使用工具生成</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Proxy和RealSubject通常是保证接口一致性，从而使客户端感觉是一致的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span> : <span class="keyword">public</span> Subject &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 对RealSubject的一种间接访问</span></span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Subject *subject;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Client</span>() &#123; subject = <span class="keyword">new</span> <span class="built_in">Proxy</span>(); &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">doTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// ...  </span></span><br><span class="line">            subject-&gt;<span class="built_in">process</span>();</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Adapter–适配器模式"><a href="#Adapter–适配器模式" class="headerlink" title="Adapter–适配器模式"></a><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Yr4y157Ci?p=16&vd_source=65122611208f4d2dd8e86fb48f5e4e28">Adapter–适配器模式</a></h2><ul>
<li><p>概念：将一个类的接口转换成客户希望的另一个接口，使原本由于接口不兼容而无法工作的那些类可以一起工作。</p>
</li>
<li><p>场景：<code>STL</code>中的有三种类型的适配器</p>
<ul>
<li>容器适配器：<code>stack</code>、<code>queue</code>、<code>priority_queue</code></li>
<li>迭代器适配器：插入迭代器、反向迭代器、流迭代器</li>
<li>仿函数适配器：绑定（<code>bind</code>）、否定（<code>negate</code>）、组合（<code>compose</code>）</li>
</ul>
</li>
</ul>
<h2 id="Iterator–迭代器模式"><a href="#Iterator–迭代器模式" class="headerlink" title="Iterator–迭代器模式"></a><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Yr4y157Ci/?p=21&spm_id_from=pageDriver&vd_source=65122611208f4d2dd8e86fb48f5e4e28">Iterator–迭代器模式</a></h2><ul>
<li><p>概念：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露（稳定）该对象的内部表示。</p>
</li>
<li><p>场景：<code>STL</code>中各种容器都提供自己专有的迭代器，需注意GOF中迭代器模是以面向对象方式中的虚函数实现运行时多态，但迭代器一般用于循环中，因此在循环次数较多时，虚函数的频繁调用（需通过虚函数表指针寻找函数地址–二次的指针间接运算）会导致极高的成本。因此<code>STL</code>中的迭代器采用模板技术实现编译时多态，以提高性能。</p>
</li>
<li><p><code>STL</code>迭代器类型（5种）</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入迭代器：只读，不允许外界改变，例如输入流迭代器。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator_tag</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// 输出迭代器：唯写，例如输出流迭代器，只重载赋值运算符</span></span><br><span class="line"><span class="comment">// 其余运算符（递增、解引用），只返回*this自身，不起作用，从而实现关闭功能。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iterator_tag</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// 前向迭代器：允许“写入型”算法在此迭代器所形成的区间上进行读写操作</span></span><br><span class="line"><span class="comment">// 例如forward_list、以哈希表实现的unordered系列set和map（vector实现的桶中的链表为单向链表）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator_tag</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// 双向迭代器：可双向移动，某些算法（copy_backward）需要逆向访问区间</span></span><br><span class="line"><span class="comment">// 例如list、以红黑树实现的set和map</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bidirectional_iterator_tag</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// 随机访问迭代器：涵盖指针所有的算术能力（加法、减法、下标运算、比较、解引用），例如vector、deque</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator_tag</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>STL</code>迭代器特性（5种）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Category</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span> = <span class="type">ptrdiff_t</span>,</span><br><span class="line">         <span class="keyword">class</span> Pointer = T*, <span class="keyword">class</span> Reference = T&amp;&gt;</span><br><span class="line"><span class="keyword">struct</span> iterator &#123;</span><br><span class="line">    <span class="keyword">typedef</span> Category  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T         value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Distance  difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> Pointer   pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Reference reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于进行迭代器特性萃取的traits技巧</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::iterator_category iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type        value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::difference_type   difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::pointer           pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::reference         reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

        </div>

        
            <section class="post-copyright">
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"># 设计模式</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2023/07/21/Project/SkipList/">基于跳表实现的有序关联容器</a>
            
            
            <a class="next" rel="next" href="/2023/06/06/Fundamentals/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1/">设计模式（上篇）</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© li jiang | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>