<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>算法（中篇）</title>
    <url>/2023/05/29/Algorithm/%E7%AE%97%E6%B3%952/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树分类"><a href="#二叉树分类" class="headerlink" title="二叉树分类"></a>二叉树分类</h3><ul>
<li>满二叉树：从上到下，从左到右全部排满，若深度（相较于根节点）为$k$（$k$从$1$开始），则节点数量为$2^k-1$。</li>
<li>完全二叉树：除了底层的叶子节点外，其他层都是满的，且底部叶子是从左到右连续的。若为第$i$（$i$从$0$开始）个节点，则左子节点为$2i+1$，右子节点为$2i+2$，父节点为$(i-1)&#x2F;2$。</li>
<li>二叉搜索树：节点按节点值的大小顺序组织（<code>left &lt; root &lt; right</code>），搜索一个节点的复杂度为$O(\log{N})$。</li>
<li>高度平衡二叉搜索树（AVL树）：除了满足二叉搜索树的特性外，还要求左右子树的高度（相较于叶子节点）差不能超过$1$，从而确保树的深度为$O(\log{N})$。当插⼊新的节点破坏平衡性时，从下往上找到第⼀个不平衡点，需要进行单旋转（外侧插入）或者双旋转（内侧插入）调整。</li>
<li>红黑树：平衡性比AVL树弱（高度相差可能超过$1$），但实际使用中也能维持良好的平衡状态，且为维持平衡而付出的代价更小，但搜索的平均效率和AVL树几乎相等。规则如下：<ul>
<li>每个节点不是红就是黑，根节点必须为黑色，且若节点为红，则其子节点必为黑。</li>
<li>任何一节点到每个叶子节点的路径都必须包含相同数量的黑色节点（新增节点必定为红）。</li>
</ul>
</li>
</ul>
<h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><ul>
<li><p>深度优先：常用递归法或迭代法（配合栈来模拟递归）实现，前序遍历、中序遍历、后序遍历都属于深度优先。</p>
<ul>
<li>递归法：三步走，确定递归函数的参数和返回值、确定递归终止条件、确定单层递归逻辑。</li>
</ul>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode *root, vector&lt;<span class="type">int</span>&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// preorder前序遍历</span></span><br><span class="line">    res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;left, res);</span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;right, res);</span><br><span class="line">    <span class="comment">// inorder中序遍历</span></span><br><span class="line">    <span class="comment">// traversal(root-&gt;left, res);</span></span><br><span class="line">    <span class="comment">// res.push_back(root-&gt;val);</span></span><br><span class="line">    <span class="comment">// traversal(root-&gt;right, res);</span></span><br><span class="line">    <span class="comment">// postorder后序遍历</span></span><br><span class="line">    <span class="comment">// traversal(root-&gt;left, res);</span></span><br><span class="line">    <span class="comment">// traversal(root-&gt;right, res);</span></span><br><span class="line">    <span class="comment">// res.push_back(root-&gt;val);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>迭代法：利用栈来模拟递归，且需考虑好访问节点与处理节点的逻辑。</li>
</ul>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前序遍历：访问节点和处理节点的顺序一致，即每次处理的均是当前访问的节点。</span></span><br><span class="line"><span class="comment">// 且每次处理（节点出栈，节点值放入数组）后，需先将节点的右子节点入栈，后将节点的左子节点入栈。</span></span><br><span class="line"><span class="comment">// 而非先处理左子节点，再处理右子节点，因为栈是先进后出的顺序。</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    stack&lt;TreeNode*&gt; stk;</span><br><span class="line">    stk.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode *node = stk.<span class="built_in">top</span>(); stk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (node) res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        stk.<span class="built_in">push</span>(node-&gt;right); stk.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 后序遍历：只需将前序遍历的入栈顺序颠倒（变为先左后右），再将结果数组元素颠倒即可。</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 与前序遍历相同处理...</span></span><br><span class="line">    <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 与前序遍历相同处理...</span></span><br><span class="line">        <span class="comment">// 此时会将结果由“根左右”变为“根右左”</span></span><br><span class="line">        stk.<span class="built_in">push</span>(node-&gt;left); skt.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再结果由“根右左”变为“左右根”</span></span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 中序遍历：访问节点和处理节点的顺序不一致，即每次访问的节点并不会被立即处理，而是先由栈暂存。</span></span><br><span class="line"><span class="comment">// 若当前访问节点非空，先将其入栈，并将左子节点作为下一个访问节点。</span></span><br><span class="line"><span class="comment">// 若当前访问节点为空，则弹出栈顶节点（收集结果），并将右子节点作为下一个访问节点。</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    stack&lt;TreeNode*&gt; stk;</span><br><span class="line">    TreeNode *cur = root; <span class="comment">// cur代表当前访问节点</span></span><br><span class="line">    <span class="keyword">while</span> (cur || !stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur) &#123; stk.<span class="built_in">push</span>(cur); cur = cur-&gt;left; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = stk.<span class="built_in">top</span>(); stk.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur-&gt;val); cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>广度优先：常用迭代法（配合队列）实现，层序遍历是广度优先的一种。</p>
<ul>
<li>迭代法：使用队列存放每层的节点，并用<code>size</code>记录当前层的节点个数。每弹出一个节点就将其左右子节点加入队列，并将<code>size--</code>。当<code>size == 0</code>，则表示遍历完一层，将<code>size</code>更新为当前队列大小，开始遍历下一层。</li>
</ul>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode *root) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    queue&lt;TreeNode*&gt; que;</span><br><span class="line">    <span class="keyword">if</span> (root) que.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        size = que.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">            TreeNode *node = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(tmp));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="完全二叉树节点数量"><a href="#完全二叉树节点数量" class="headerlink" title="完全二叉树节点数量"></a>完全二叉树节点数量</h3><ul>
<li>方法1：将其当作普通二叉树，则前、中、后、层序遍历都可计算，但时间复杂度为$O(N)$，相对低效。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 后序遍历思想</span></span><br><span class="line">    <span class="keyword">return</span> root ? <span class="built_in">countNodes</span>(root-&gt;left) + <span class="built_in">countNodes</span>(root-&gt;right) + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法2：由于完全二叉树及其子树可能为满二叉树，那么就可使用$2^k-1$来快速计算节点数，$k$为满二叉树的深度。因此每次递归需先判断当前树是否为满二叉树，若是则利用公式快速计算节点数；若不是，则通过后序遍历来计算节点数。对于满二叉树判断，需结合完全二叉树从左到右节点连续的特性（右子节点不空，则必定存在左子节点），因此若一直向左走到叶节点的路径经过的节点数等于一直向右走到叶节点的路径经过的节点数，那么该树为满二叉树。从而避免了遍历所有节点，只需遍历树最外侧的两条路径，时间复杂度$\leq{O(N)}$。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> leftDepth = <span class="number">0</span>, rightDepth = <span class="number">0</span>;</span><br><span class="line">    TreeNode *left = root-&gt;left, *right = root-&gt;right;</span><br><span class="line">    <span class="keyword">while</span> (left) &#123; ++leftDepth; left = left-&gt;left; &#125; <span class="comment">// 计算左外侧路径的节点数</span></span><br><span class="line">    <span class="keyword">while</span> (right) &#123; ++rightDepth; right = right-&gt;right; &#125; <span class="comment">// 计算右外侧路径的节点数</span></span><br><span class="line">    <span class="comment">// 两侧路径的节点数相同为满二叉树，则快速计算节点数</span></span><br><span class="line">    <span class="keyword">if</span> (leftDepth == rightDepth) <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftDepth) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 两侧路径的节点数不同，则后序遍历计算节点数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">countNodes</span>(root-&gt;left) + <span class="built_in">countNodes</span>(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树中的回溯（二叉树左下角值）"><a href="#二叉树中的回溯（二叉树左下角值）" class="headerlink" title="二叉树中的回溯（二叉树左下角值）"></a>二叉树中的回溯（<a href="https://leetcode.cn/problems/find-bottom-left-tree-value/description/">二叉树左下角值</a>）</h3><ul>
<li>方法1：利用层序遍历，最后一层的第一个节点即为目标节点，但相对低效。</li>
<li>方法2：将问题转换为找最后一层（节点深度必定最大)，可利用递归（遍历）加回溯（记录最大深度）来解决。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局变量记录最大深度和目标值</span></span><br><span class="line"><span class="type">int</span> maxDepth = INT_MIN, res;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode *root, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件，到达叶子节点，此时收割结果</span></span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (depth &gt; maxDepth) &#123; maxDepth = depth; res = root-&gt;val; &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每次优先从左遍历，因为要求的是左下角的值</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">        ++depth;</span><br><span class="line">        <span class="built_in">findBottomLeftValue</span>(root-&gt;left, depth);</span><br><span class="line">        --depth; <span class="comment">// 回撤操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将回撤操作隐含在参数传递中</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right) <span class="built_in">findBottomLeftValue</span>(root-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">findBottomLeftValue</span>(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h3><ul>
<li>方法1：中序遍历，将遍历结果存入数组，验证结果是否单调递增（暴力解法，效率低）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">isValidBST</span>(root-&gt;left);</span><br><span class="line">    nums.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123; <span class="keyword">if</span> (nums[i] &lt;= nums[i<span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法2：前序遍历，利用区间范围概念，左子树中所有节点必小于根节点，右子树中所有节点必大于根节点。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该方法缺点在于，需根据节点值类型来确定上下限类型，上下限类型表示的范围要比节点值类型大</span></span><br><span class="line"><span class="comment">// 如节点值可能就是INT_MIN，那么如下限取INT_MIN，则始终返回true</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode *root, <span class="type">long</span> lower, <span class="type">long</span> upper)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt;= upper || root-&gt;val &lt;= lower) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root-&gt;left, lower, root-&gt;val) &amp;&amp;</span><br><span class="line">        <span class="built_in">isValidBST</span>(root-&gt;right, root-&gt;val, upper);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode *root)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root, LONG_MIN, LONG_MAX); &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法3：双指针+中序遍历（但凡遇到需利用二叉搜索树特性时，就必定是中序遍历）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TreeNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isValidBST</span>(root-&gt;left)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 判断前继指针所指节点的值和当前指针所指节点的值。</span></span><br><span class="line">    <span class="keyword">if</span> (pre &amp;&amp; pre-&gt;val &gt;= root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    pre = root; <span class="comment">// 更新前继节点，相当于回溯过程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>组合：不强调元素顺序，求出所有元素中满足条件的所有组合；</li>
<li>切割：在字符串中，切割出所有满足特定条件的子串；</li>
<li>子集：列出元素所构成的所有子集；</li>
<li>排列：相较于组合，排列强调元素顺序，相同元素不同顺序的组合可构成一个排列，但都只是同一个组合；</li>
<li>棋盘：$N$皇后和解数独等二维数组问题。</li>
</ul>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><ul>
<li>可抽象成$N$叉树，树宽为所处理的集合大小（<code>for</code>循环遍历），树深即为递归的深度，本质上是递归嵌套循环。</li>
</ul>
<h3 id="三步走策略"><a href="#三步走策略" class="headerlink" title="三步走策略"></a>三步走策略</h3><ul>
<li>确定参数（通常较多，且一般有两个引用参数用于收集中间过程和结果）和返回值（通常是<code>void</code>）；</li>
<li>确定递归终止条件（叶子节点收集结果）；</li>
<li>单层搜索逻辑（<code>for</code>循环），且一定要注意回撤操作。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backTrace</span><span class="params">(参数...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (递归终止条件) &#123;</span><br><span class="line">        收集结果（叶子节点）;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (集合中的元素) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="comment">// 一般在递归函数中，需要更新startIndex</span></span><br><span class="line">        <span class="comment">// 若不允许重复使用集合中的元素，则startIndex更新为i+1，leetcode216</span></span><br><span class="line">        <span class="comment">// 若允许重复使用集合中的元素，则startIndex更新为i，leetcode39</span></span><br><span class="line">        <span class="comment">// 若为切割字符串，则startIndex常用于模拟当前切割的起始位置，而i为切割线位置，leetcode93</span></span><br><span class="line">        <span class="built_in">backTrace</span>(参数...);</span><br><span class="line">        回溯操作，撤销处理的节点;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剪枝操作"><a href="#剪枝操作" class="headerlink" title="剪枝操作"></a>剪枝操作</h3><ul>
<li>一般在单层搜索逻辑中的<code>for</code>循环的条件判断中进行剪枝，如<a href="https://leetcode.cn/problems/combinations/submissions/">组合问题</a>：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原先的搜索范围到n才会终止</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n; ++i) &#123;</span><br><span class="line">    path.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">backTrace</span>(...);</span><br><span class="line">    path.<span class="built_in">pop_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 剪枝，缩小搜索范围，n表示所有可取的元素数量，k表示总共需要的元素数量，path.size()表示已有的元素数量</span></span><br><span class="line"><span class="comment">// 那么k-path.size()就表示还需要搜索的元素数量，则n-(k-path.size())+1表示当前i可取到的最大值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n-(k-path.<span class="built_in">size</span>())+<span class="number">1</span>; ++i) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<h3 id="去重操作"><a href="#去重操作" class="headerlink" title="去重操作"></a>去重操作</h3><ul>
<li><p>场景：集合中的元素存在重复，但要求解集是不能包含重复的组合。</p>
</li>
<li><p>情况1：不要求结果集中的元素相对顺序和原集合中的相对顺序一致，<a href="https://www.bilibili.com/video/BV12V4y1V73A/?p=66&spm_id_from=pageDriver">leetcode40</a>。</p>
<ul>
<li>需要先对原集合进行排序，还需要辅助数组<code>used</code>记录集合中元素是否被使用(<code>true</code>或<code>false</code>)。</li>
</ul>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>树层去重：在<code>for</code>循环中若前一个元素与当前元素相同，且前一个元素的使用状态为<code>used[i-1] == false</code>（表明第<code>i-1</code>个元素已处理过了，当前正从第<code>i</code>个元素开始处理，因为每个元素处理过后，<code>used</code>会重置为<code>false</code>），则出现树层重复（此时的处理过程已在第<code>i-1</code>个元素的处理过程中出现过了），直接<code>continue</code>。</li>
</ul>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="comment">// 树层去重操作</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i<span class="number">-1</span>] == nums[i] &amp;&amp; !used[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">    used[i] = <span class="literal">true</span>;</span><br><span class="line">    ...</span><br><span class="line">    used[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>情况2：要求结果集中的元素相对顺序和原集合中的相对顺序保持一致，<a href="https://www.bilibili.com/video/BV1EG4y1h78v/?spm_id_from=333.788&vd_source=65122611208f4d2dd8e86fb48f5e4e28">leetcode491</a>。</p>
<ul>
<li>此时不需要对原集合进行排序，且不需要使用辅助数组<code>used</code>。</li>
<li>树层去重：去重逻辑为在每次<code>for</code>循环中检查当前的元素（第<code>i</code>个），在从<code>startIndex</code>至<code>i</code>所表示的区间中是否已出现过，若重复出现，则直接<code>continue</code>。</li>
</ul>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="comment">// 树层去重操作</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(nums.<span class="built_in">begin</span>() + startIndex, nums.<span class="built_in">begin</span>() + i, nums[i])</span><br><span class="line">            != nums.<span class="built_in">begin</span>() + i) <span class="keyword">continue</span>;</span><br><span class="line">    ... <span class="comment">// 不需要使用used数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h3><ul>
<li>方法1：相较于组合问题，排列问题强调元素顺序，元素相同但顺序不同可构成不同排列，但只属于同一种组合，所以排列情况更多。因此，排列中的<code>for</code>循环逻辑不再需要<code>startIndex</code>来标记每次的起始位置，每次均需遍历整个元素集合。同时还需<code>used</code>数组来避免元素重复使用，且排列的终止条件为路径中元素数和原集合中元素数相等时。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归终止条件</span></span><br><span class="line"><span class="keyword">if</span> (nums.<span class="built_in">size</span>() == path.<span class="built_in">size</span>()) &#123; res.<span class="built_in">push_back</span>(path); <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="comment">// 每次均需遍历整个集合，而非从startIndex开始</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>; <span class="comment">// 此处的used概念与树层去重中的used概念不同</span></span><br><span class="line">    used[i] = <span class="literal">true</span>;</span><br><span class="line">    ...</span><br><span class="line">    used[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法2：除了使用回溯外，还可以借助<code>next_permutation</code>库函数来生成全排列，前提是需要对原集合先进行排序。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(nums)</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()));</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="棋盘问题"><a href="#棋盘问题" class="headerlink" title="棋盘问题"></a>棋盘问题</h3><ul>
<li>$N$皇后：以行数<code>row</code>来判断递归终止，在<code>for</code>循环中使用<code>i</code>作为列数，且每次均从$0$开始以遍历整个列。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否满足N皇后规则</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(vector&lt;string&gt; &amp;board, <span class="type">int</span> row, <span class="type">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; ++i) <span class="comment">// 检查列方向上是否冲突</span></span><br><span class="line">        <span class="keyword">if</span> (board[i][col] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 检查左上45度角是否冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = row<span class="number">-1</span>, j = col<span class="number">-1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; --i, --j)</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 检查右上45度角是否冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = row<span class="number">-1</span>, j = col+<span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); --i, ++j)</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backTrace</span><span class="params">(vector&lt;vector&lt;string&gt;&gt; &amp;res, vector&lt;string&gt; &amp;board, <span class="type">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 以row控制递归终止，当处理完最后一行之后终止递归</span></span><br><span class="line">    <span class="keyword">if</span> (row == board.<span class="built_in">size</span>()) &#123; res.<span class="built_in">push_back</span>(board); <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="comment">// 以i来控制当前处理的列，每次需遍历整个列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isValid</span>(board, row, i)) <span class="keyword">continue</span>;</span><br><span class="line">        board[row][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        <span class="built_in">backTrace</span>(res, board, row + <span class="number">1</span>);</span><br><span class="line">        board[row][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    <span class="comment">// 此处board相当于先前的path，用于收集中间结果</span></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">board</span><span class="params">(n, string(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">    <span class="built_in">backTrace</span>(res, board, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解数独：本质上是二维回溯，两层<code>for</code>循环，分别控制行和列，每次均从$0$开始遍历整个行或列。且回溯函数的返回值为<code>bool</code>类型，不再是<code>void</code>类型。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否满足解数独规则</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; &amp;board, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查列方向上是否冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123; <span class="keyword">if</span> (i != col &amp;&amp; board[row][i] == c) <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="comment">// 检查行方向上是否冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123; <span class="keyword">if</span> (i != row &amp;&amp; board[i][col] == c) <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="comment">// 检查所属的九宫格范围内是否冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = (row/<span class="number">3</span>)*<span class="number">3</span>; i &lt; (row/<span class="number">3</span>+<span class="number">1</span>)*<span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = (col/<span class="number">3</span>)*<span class="number">3</span>; j &lt; (col/<span class="number">3</span>+<span class="number">1</span>)*<span class="number">3</span>; ++j)</span><br><span class="line">            <span class="keyword">if</span> (i != row &amp;&amp; j != col &amp;&amp; board[i][j] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">backTrace</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; &amp;board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; <span class="number">9</span>; ++row) &#123; <span class="comment">// 控制所有行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; <span class="number">9</span>; ++col) &#123; <span class="comment">// 控制所有列</span></span><br><span class="line">            <span class="keyword">if</span> (board[row][col] ^ <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>; <span class="comment">// 若当前位置已有数字字符，则不处理</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="string">&#x27;1&#x27;</span>; i &lt;= <span class="string">&#x27;9&#x27;</span>; ++i ) &#123; <span class="comment">// 对于每个空白位置，都存在9中可能的数字字符</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">isValid</span>(board, row, col, i)) <span class="keyword">continue</span>;</span><br><span class="line">                board[row][col] = i;</span><br><span class="line">                <span class="comment">// 若接下来的递归调用返回true，则表明已经找到结果，直接返回即可</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">backTrace</span>(board)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 若9中数字字符均尝试完毕，但仍未返回，则表明解数独失败</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123; <span class="built_in">backTrace</span>(board); &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>算法（上篇）</title>
    <url>/2023/05/25/Algorithm/%E7%AE%97%E6%B3%951/</url>
    <content><![CDATA[<h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><ul>
<li><p>场景：常用于有序或部分有序区间（前提条件）查找目标元素，时间复杂度为$O(\log{N})$。</p>
</li>
<li><p>方法：可分为左闭右闭和左闭右开两种，重点是要正确处理边界条件。</p>
</li>
<li><p>模版</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一：左闭右闭区间[left,right]</span></span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = size - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 此时可通过判断是否处于合法区间定义来决定是&lt;还是&lt;=</span></span><br><span class="line"><span class="comment">// 当left = right时，在[left,right]中是有效的，所以可以是&lt;=</span></span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 更新左区间的右边界</span></span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">        <span class="comment">// 此时继续根据区间定义来决定right更新为mid还是mid-1，由于此时nums[mid]不为target</span></span><br><span class="line">        <span class="comment">// 所以nums[mid]必定不在下一次查找范围中，因此right应该更新为mid-1</span></span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新右区间的左边界</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">        left = mid + <span class="number">1</span>; <span class="comment">// 更新原理与上面相同</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：左闭右开区间[left,right)</span></span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = size;</span><br><span class="line"><span class="comment">// 此时若left = right，那么在原合法区间[left,right)定义中就没有意义，所以应该为&lt;</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 由于区间定义为左闭右开，所以下一次搜索中nums[mid]必定不包含在其中，因此right更新为mid</span></span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &gt; target) &#123; right = mid; &#125;</span><br><span class="line">    <span class="comment">// 由于区间定义为左闭右开，所以下一次搜索中必定包含左边界</span></span><br><span class="line">    <span class="comment">// 而此处nums[mid]已经确定和target不同，所以left更新为mid+1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123; left = mid + <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h3><ul>
<li><p>场景：常用于查找序列中的元素是否出现、出现频次以及出现位置，时间复杂度为$O(1)$。</p>
</li>
<li><p>方法：可以使用原生数组、<code>map/unordered_map</code>、<code>set/unordered_set</code>进行处理，一般情况下，优先考虑使用<code>unordered_map/unordered_set</code>（哈希表），效率更高，但若对元素顺序有要求，则使用<code>map/set</code>（红黑树）。</p>
<ul>
<li>原生数组：效率高，但要求预分配的大小不能超过$1000$；</li>
<li><code>map/unordered_map</code>：用于查找元素出现频次或出现位置；</li>
<li><code>set/unordered_set</code>：用于查找元素是否出现。</li>
</ul>
</li>
</ul>
<h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h3 id="栈：先进后出"><a href="#栈：先进后出" class="headerlink" title="栈：先进后出"></a>栈：先进后出</h3><ul>
<li>对序列中相邻元素进行处理或特殊判断（括号匹配，消除相邻元素）。</li>
<li>栈实现队列：两个栈，<code>stk1</code>接收元素，<code>stk2</code>用于出元素。且只当<code>stk2</code>空时，才会将<code>stk1</code>中元素添加到<code>stk2</code>。</li>
<li>逆波兰表达式（后缀表达式）：计算机处理表达式的方式，无需考虑括号，用栈处理即可。<ul>
<li>逆波兰表达式转换：将常规表达式（中缀表达式）看作表达式树（二叉树），其后序遍历结果便是后缀表达式。</li>
</ul>
</li>
</ul>
<h3 id="队列：先进先出"><a href="#队列：先进先出" class="headerlink" title="队列：先进先出"></a>队列：先进先出</h3><ul>
<li>队列实现栈<ul>
<li>两个队列：始终保证一个队列为空，每次出元素均需将非空队列中除最后一个元素外的所有元素都搬到空队列。</li>
<li>一个队列：每次出元素均将最后一个元素前的所有元素重新加入队列中。</li>
</ul>
</li>
<li>滑动窗口最大值<ul>
<li>单调队列<ul>
<li>使用<code>deque</code>作为底层容器，实现单调队列。</li>
<li>保证队列出口处元素始终为队列元素中的最大（最小）值，并维护队列中的元素单调递减（递增）。</li>
</ul>
</li>
<li>窗口每滑动一次就会抛弃原先窗口的首元素<ul>
<li>若队列出口元素与该抛弃元素相同，则队列也弹出出口元素。</li>
<li>若队列出口元素与该抛弃元素不同，则不做任何处理。</li>
</ul>
</li>
<li>窗口每滑动一次就需要将新窗口的尾元素添加到队列中<ul>
<li>先从队列中弹出所有小于该新元素的队列元素，再将该新元素添加到队列中，以维持队列单调递减。</li>
</ul>
</li>
<li>每次从单调队列中获取的队首元素即为当前滑动窗口的最大值</li>
</ul>
</li>
</ul>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul>
<li>时间复杂度为$O(N^2)$，最差情况$O(N^2)$，空间复杂度为$O(1)$。</li>
<li>Step1: 比较每对相邻元素，若第一个比第二个大，则交换；</li>
<li>Step2: 这样最大元素就像冒泡一样上浮至最后一个元素位置；</li>
<li>Step3: 在剩下的元素中重复上述步骤（Step1~2）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) std::<span class="built_in">swap</span>(arr[j], arr[j+<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul>
<li>时间复杂度为$O(N^2)$，最差情况$O(N^2)$，空间复杂度为$O(1)$。</li>
<li>Step1: 从头到尾定位最小元素，将最小元素与第一个元素交换位置；</li>
<li>Step2: 在剩下的元素中找最小元素，将其与第二个元素交换位置，重复处理即可。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">select_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; len; ++j)</span><br><span class="line">			<span class="keyword">if</span> (arr[i] &gt; arr[j]) std::<span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul>
<li>时间复杂度为$O(N^2)$，最差情况$O(N^2)$，空间复杂度为$O(1)$，适用于部分有序数组和小规模数组。</li>
<li>Step1: 对于未排序的元素，在已排序的元素中从后向前扫描，找到相应位置插入；</li>
<li>Step2: 为给待插入元素腾出空间，需将插入位置之后的已排序元素都后移一位。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> cur = i + <span class="number">1</span>, j = i;</span><br><span class="line">		<span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &lt;= arr[cur]) <span class="keyword">break</span>;</span><br><span class="line">			--j;</span><br><span class="line">		&#125;</span><br><span class="line">		++j;</span><br><span class="line">		<span class="type">int</span> tmp = arr[cur];</span><br><span class="line">		<span class="keyword">while</span> (cur &gt; j) &#123;</span><br><span class="line">			arr[cur] = arr[cur<span class="number">-1</span>];</span><br><span class="line">			--cur;</span><br><span class="line">		&#125;</span><br><span class="line">		arr[j] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ul>
<li>时间复杂度为$O(N\log{N})$，最差情况$O(N\log{N})$，空间复杂度为$O(N)$。</li>
<li>Step1: 将序列划分成子序列，通过递归完成，递归终止条件为子序列长度小于$2$；</li>
<li>Step2: 将排好序的子序列两两合并，从而获得一个更长的有序序列。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> *arr1, <span class="type">int</span> len1, <span class="type">int</span> *arr2, <span class="type">int</span> len2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *tmp = <span class="keyword">new</span> <span class="type">int</span>[len1+len2]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>; k &lt; len1+len2; ++k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == len1) tmp[k] = arr2[j++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j == len2) tmp[k] = arr1[i++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr1[i] &lt; arr2[j]) tmp[k] = arr1[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k] = arr2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len1; ++i) arr1[i] = tmp[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len2; ++i) arr2[i] = tmp[len1+i];</span><br><span class="line">    <span class="keyword">delete</span> [] tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 划分子序列，划分成几个子序列就是几路归并</span></span><br><span class="line">    <span class="comment">// 这里选择划分成两个子序列，因此是二路归并</span></span><br><span class="line">    <span class="type">int</span> mid = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> *left_arr = arr;</span><br><span class="line">    <span class="type">int</span> *right_arr = arr + mid;</span><br><span class="line">    <span class="comment">// 对子序列进行排序</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(left_arr, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(right_arr, len - mid);</span><br><span class="line">    <span class="comment">// 合并有序的两个子序列</span></span><br><span class="line">    <span class="built_in">merge</span>(left_arr, mid, right_arr, len - mid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ul>
<li>时间复杂度为$O(N\log{N})$，最差情况$O(N^2)$，空间复杂度为$O(1)$。</li>
<li>分割函数：选择一个基准点，且分割函数使基准点左侧元素均小于等于基准点位置的元素，而基准点右侧元素均大于基准点位置的元素。<ul>
<li>Step1: 随机选择一个基准点，并将基准点位置的元素与尾元素交换；</li>
<li>Step2: 使用两个索引，分区索引（初始化为首前位置），遍历索引（首元素位置）。通过遍历索引遍历所有元素，若遍历索引的当前元素值小于等于尾元素，则分区索引右移，且若分区索引右移后仍在遍历索引左侧，则交换两个位置的元素；若遍历索引的当前元素值大于尾元素，则不做任何处理；</li>
<li>Step3: 返回分区索引即可。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分割函数，左闭右开区间</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> beg, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 取[a,b)随机数rand%(b-a)+a，取[a,b]随机数rand%(b-a+1)+a</span></span><br><span class="line">	<span class="type">int</span> pivot = <span class="built_in">rand</span>() % (end - beg) + beg;</span><br><span class="line">	std::<span class="built_in">swap</span>(arr[pivot], arr[end<span class="number">-1</span>]);</span><br><span class="line">	<span class="type">int</span> pre, cur;</span><br><span class="line">	<span class="keyword">for</span> (pre = beg - <span class="number">1</span>, cur = beg; cur &lt; end; ++cur) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[cur] &lt;= arr[end<span class="number">-1</span>] &amp;&amp; ++pre &lt; cur)</span><br><span class="line">			std::<span class="built_in">swap</span>(arr[pre], arr[cur]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>快排递归：对基准点左侧元素和右侧元素分别通过递归方式进行快排，递归终止条件为只剩0个元素。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __quick_sort(<span class="type">int</span> *arr, <span class="type">int</span> beg, <span class="type">int</span> end) &#123;</span><br><span class="line">	<span class="comment">// beg和end为左闭右开区间</span></span><br><span class="line">	<span class="keyword">if</span> (beg == end) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> idx = <span class="built_in">partition</span>(arr, beg, end);</span><br><span class="line">	<span class="keyword">if</span> (idx &gt; beg) __quick_sort(arr, beg, idx);</span><br><span class="line">	<span class="keyword">if</span> (idx &lt; end) __quick_sort(arr, idx + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统一测试接口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	__quick_sort(arr, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ul>
<li>时间复杂度为$O(N\log{N})$，最差情况$O(N\log{N})$，空间复杂度为$O(1)$。</li>
<li>下滤操作：将$i$处节点与其子节点比较，若子节点值大于$i$处节点值，则交换节点值，并将$i$更新为其子节点索引，持续下滤直至$i$节点值大于其子节点值或到达叶子节点。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shift_down</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> hole_idx = i;</span><br><span class="line">	<span class="type">int</span> left_idx = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> right_idx = left_idx + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (left_idx &lt; len &amp;&amp; arr[left_idx] &gt; arr[hole_idx])</span><br><span class="line">		hole_idx = left_idx;</span><br><span class="line">	<span class="keyword">if</span> (right_idx &lt; len &amp;&amp; arr[right_idx] &gt; arr[hole_idx])</span><br><span class="line">		hole_idx = right_idx;</span><br><span class="line">	<span class="keyword">if</span> (hole_idx ^ i) &#123;</span><br><span class="line">		std::<span class="built_in">swap</span>(arr[hole_idx], arr[i]);</span><br><span class="line">		<span class="built_in">shift_down</span>(arr, len, hole_idx);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>建堆函数：构造大顶堆，从最后一个非叶节点（即尾元素节点$len-1$的父节点$(len-2)&#x2F;2&#x3D;len&#x2F;2-1$）开始，至首元素节点结束，依次下滤以调整堆结构，时间复杂度为$O(N\log{N})$。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_heap</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = (len - <span class="number">2</span>) &gt;&gt; <span class="number">1</span>; i &gt;=<span class="number">0</span> ; --i) <span class="built_in">shift_down</span>(arr, len, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>迭代法排序：首先构建一个大顶堆，再每次交换首元素与尾元素，并将数组长度减$1$后下滤首元素，循环终止条件为数组长度$\leq1$。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">build_heap</span>(arr, len);</span><br><span class="line">	<span class="keyword">while</span> (len &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		std::<span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[--len]);</span><br><span class="line">		<span class="built_in">shift_down</span>(arr, len, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort_test</span><span class="params">(sort_fun sort, <span class="type">const</span> std::string &amp;msg, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> std::default_random_engine e;</span><br><span class="line">	<span class="function"><span class="type">static</span> std::uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">u</span><span class="params">(<span class="number">0</span>, len)</span></span>;</span><br><span class="line">	<span class="type">int</span> arr[len];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) arr[i] = <span class="built_in">u</span>(e);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;=&gt; &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">	<span class="function">std::ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">oiter</span><span class="params">(std::cout, <span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;source arr: &quot;</span>;</span><br><span class="line">	std::<span class="built_in">copy</span>(arr, arr + len, oiter);</span><br><span class="line">	std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(arr, len);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;after sort: &quot;</span>;</span><br><span class="line">	std::<span class="built_in">copy</span>(arr, arr + len, oiter);</span><br><span class="line">	std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">	std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (argc &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; array_size&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot;Invalid array_size&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort_test</span>(bubble_sort, <span class="string">&quot;Bubble Sort&quot;</span>, len);</span><br><span class="line">	<span class="built_in">sort_test</span>(select_sort, <span class="string">&quot;Select Sort&quot;</span>, len);</span><br><span class="line">	<span class="built_in">sort_test</span>(insert_sort, <span class="string">&quot;Insert Sort&quot;</span>, len);</span><br><span class="line">	<span class="built_in">sort_test</span>(merge_sort, <span class="string">&quot;Merge Sort&quot;</span>, len);</span><br><span class="line">	<span class="built_in">sort_test</span>(quick_sort, <span class="string">&quot;Quick Sort&quot;</span>, len);</span><br><span class="line">	<span class="built_in">sort_test</span>(heap_sort, <span class="string">&quot;Heap Sort&quot;</span>, len);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>查找算法</tag>
        <tag>栈与队列</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++轻量级多线程Web服务器（下篇）</title>
    <url>/2023/08/01/Project/WebServer2/</url>
    <content><![CDATA[<span id="more"></span>

<p>本项目地址：<a href="https://github.com/lijiang99/WebServer">https://github.com/lijiang99/WebServer</a></p>
<p>参考资料：<a href="https://dark-wind.github.io/books/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.pdf">《Linux高性能服务器编程》</a>、<a href="https://github.com/qinguoyi/TinyWebServer/tree/raw_version">TinyWebServer</a>、<a href="https://github.com/markparticle/WebServer">WebServer（C++版）</a></p>
<h2 id="Day4-日志系统实现"><a href="#Day4-日志系统实现" class="headerlink" title="Day4: 日志系统实现"></a>Day4: 日志系统实现</h2><ul>
<li><p>日志系统概念</p>
<ul>
<li>同步日志：日志写入与工作线程串行执行，由于涉及到文件I&#x2F;O，当单条日志比较大的时候，同步模式会阻塞整个处理流程，降低服务器的并发能力。</li>
<li>异步日志：将日志内容先存入阻塞队列，专门创建一个写线程从阻塞队列中取出内容，并写入日志文件。</li>
</ul>
</li>
<li><p>日志系统实现</p>
<ul>
<li><p>阻塞队列：使用条件变量设计生产者&#x2F;消费者模型，其实就是封装了个双端队列（<code>deque</code>），只不过需要在添加元素和删除元素时注意条件变量和互斥锁的使用，乏善可陈。</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义阻塞队列状态类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">bool</span> _block_queue_status_type;</span><br><span class="line"><span class="type">const</span> _block_queue_status_type _queue_open = <span class="literal">true</span>;</span><br><span class="line"><span class="type">const</span> _block_queue_status_type _queue_close = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 阻塞队列，用于异步写入日志信息</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_block_queue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">typedef</span> _block_queue_status_type queue_status_type;</span><br><span class="line">        <span class="comment">// 队列状态（打开/关闭）</span></span><br><span class="line">        queue_status_type _queue_status;</span><br><span class="line">        <span class="comment">// 底层容器使用双端队列</span></span><br><span class="line">        std::deque&lt;T&gt; _deque;</span><br><span class="line">        <span class="comment">// 队列的最大容量</span></span><br><span class="line">        std::<span class="type">size_t</span> _max_capacity;</span><br><span class="line">        <span class="comment">// 保护队列的互斥锁</span></span><br><span class="line">        std::mutex _mutex;</span><br><span class="line">        <span class="comment">// 用于生产者/消费者模型的条件变量，需要搭配互斥锁一起使用</span></span><br><span class="line">        std::condition_variable _cond_producer;</span><br><span class="line">        std::condition_variable _cond_consumer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数和析构函数</span></span><br><span class="line">        <span class="keyword">explicit</span> _block_queue(<span class="type">int</span> max_capacity = <span class="number">1000</span>);</span><br><span class="line">        ~_block_queue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列的添加/删除元素的操作</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T &amp;item)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T &amp;item)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">_block_queue&lt;T&gt;::_block_queue(<span class="type">int</span> max_capacity) : _queue_status(_queue_open) &#123;</span><br><span class="line">    <span class="keyword">if</span> (max_capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;invalid number of max_capacity&quot;</span>);</span><br><span class="line">    _max_capacity = <span class="built_in">static_cast</span>&lt;std::<span class="type">size_t</span>&gt;(max_capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数，关闭队列并唤醒所有阻塞的线程（生产者/消费者）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">_block_queue&lt;T&gt;::~_block_queue() &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">    _deque.<span class="built_in">clear</span>();</span><br><span class="line">    _queue_status = _queue_close;</span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line">    _cond_producer.<span class="built_in">notify_all</span>();</span><br><span class="line">    _cond_consumer.<span class="built_in">notify_all</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在队列尾部添加元素</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> _block_queue&lt;T&gt;::<span class="built_in">push</span>(<span class="type">const</span> T &amp;item) &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (_deque.<span class="built_in">size</span>() &gt;= _max_capacity)</span><br><span class="line">        _cond_producer.<span class="built_in">wait</span>(lock);</span><br><span class="line">    _deque.<span class="built_in">push_back</span>(item);</span><br><span class="line">    _cond_consumer.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出队列头部元素，并将元素值赋给引用传递的item</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> _block_queue&lt;T&gt;::<span class="built_in">pop</span>(T &amp;item) &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (_deque.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        _cond_consumer.<span class="built_in">wait</span>(lock);</span><br><span class="line">        <span class="keyword">if</span> (_queue_status == _queue_close) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    item = _deque.<span class="built_in">front</span>();</span><br><span class="line">    _deque.<span class="built_in">pop_front</span>();</span><br><span class="line">    _cond_producer.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用单例模式（懒汉式），可根据初始化时是否设置阻塞队列容量（<code>max_queue_capacity</code>）来判断是同步还是异步日志。</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义日志初始化状态类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">bool</span> _log_status_type;</span><br><span class="line"><span class="type">const</span> _log_status_type _log_initialized = <span class="literal">true</span>;</span><br><span class="line"><span class="type">const</span> _log_status_type _log_uninitialized = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义日志写入模式类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">bool</span> _log_write_mode_type;</span><br><span class="line"><span class="type">const</span> _log_write_mode_type _async_write = <span class="literal">true</span>;</span><br><span class="line"><span class="type">const</span> _log_write_mode_type _sync_write = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志类，可用于同步/异步写入日志</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">log</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">typedef</span> _log_status_type log_status_type;</span><br><span class="line">        <span class="keyword">typedef</span> _log_write_mode_type write_mode_type;</span><br><span class="line">        <span class="keyword">typedef</span> _block_queue&lt;std::string&gt; log_queue_type;</span><br><span class="line"></span><br><span class="line">        std::string _dir_path; <span class="comment">// 路径名</span></span><br><span class="line">        std::string _file_path; <span class="comment">// 日志文件路径</span></span><br><span class="line">        std::<span class="type">size_t</span> _max_lines; <span class="comment">// 最大行数</span></span><br><span class="line">        std::<span class="type">size_t</span> _cnt_lines; <span class="comment">// 行数记录</span></span><br><span class="line">        std::chrono::days _days; <span class="comment">// 记录当前时间是哪一天</span></span><br><span class="line">        write_mode_type _write_mode; <span class="comment">// 写入方式</span></span><br><span class="line">        log_queue_type *_log_queue; <span class="comment">// 阻塞队列</span></span><br><span class="line">        std::ofstream _file_output; <span class="comment">// 文件输出流</span></span><br><span class="line">        <span class="comment">// 原子变量，用于判断日志单例是否已经初始化</span></span><br><span class="line">        std::atomic&lt;log_status_type&gt; _log_status;</span><br><span class="line">        std::mutex _mutex; <span class="comment">// 互斥锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// 使用单例模式，声明私有构造，并禁止拷贝操作</span></span><br><span class="line">        <span class="built_in">log</span>() : _cnt_lines(<span class="number">0</span>), _log_queue(<span class="literal">nullptr</span>), _log_status(_log_uninitialized) &#123;&#125;</span><br><span class="line">        <span class="built_in">log</span>(<span class="type">const</span> log &amp;rhs) = <span class="keyword">delete</span>;</span><br><span class="line">        log&amp; <span class="keyword">operator</span>=(<span class="type">const</span> log &amp;rhs) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 静态成员函数，获取单例模式的实例</span></span><br><span class="line">        <span class="function"><span class="type">static</span> log* <span class="title">get_instance</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 初始化单例模式的实例</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">const</span> std::string &amp;dir_path, <span class="type">int</span> max_lines, <span class="type">int</span> max_queue_capacity = <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 析构函数，需要在内部销毁阻塞队列，并关闭文件输出流</span></span><br><span class="line">        ~<span class="built_in">log</span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> (_log_queue) <span class="keyword">delete</span> _log_queue;</span><br><span class="line">            _file_output.<span class="built_in">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 采用单例模式（懒汉式），并使用局部静态变量确保线程安全</span></span><br><span class="line"><span class="function">log* <span class="title">log::get_instance</span><span class="params">()</span> </span>&#123; <span class="type">static</span> log logger; <span class="keyword">return</span> &amp;logger; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 根据初始化状态判断是否真的需要初始化全局唯一的日志对象，并确保线程安全</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log::init</span><span class="params">(<span class="type">const</span> std::string &amp;dir_path, <span class="type">int</span> max_lines, <span class="type">int</span> max_queue_capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 利用原子变量和CAS操作判断日志对象是否已经初始化过</span></span><br><span class="line">    log_status_type expected = _log_uninitialized;</span><br><span class="line">    <span class="keyword">if</span> (!_log_status.<span class="built_in">compare_exchange_weak</span>(expected, _log_initialized))</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;logger already initialized&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (dir_path.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;invalid directory path for saving the log file&quot;</span>);</span><br><span class="line">    _dir_path = (dir_path[dir_path.<span class="built_in">size</span>()<span class="number">-1</span>] == <span class="string">&#x27;/&#x27;</span> ? dir_path : dir_path + <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (max_lines &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;invalid number of max_lines&quot;</span>);</span><br><span class="line">    <span class="comment">// 单个日志文件可存储的最大行数</span></span><br><span class="line">    _max_lines = <span class="built_in">static_cast</span>&lt;std::<span class="type">size_t</span>&gt;(max_lines);</span><br><span class="line">    <span class="comment">// 若设置了阻塞队列大小，则表示采取异步日志模式</span></span><br><span class="line">    <span class="comment">// 否则默认为0（或设置小于0），表示采取同步日志模式</span></span><br><span class="line">    <span class="keyword">if</span> (max_queue_capacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        _write_mode = _async_write;</span><br><span class="line">        <span class="keyword">if</span> (!(_log_queue = <span class="keyword">new</span> <span class="built_in">log_queue_type</span>(max_queue_capacity)))</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to allocate memory for log queue&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建写线程，专门用于异步写入日志信息</span></span><br><span class="line">        std::<span class="built_in">thread</span>(&amp;log::async_write_log, <span class="keyword">this</span>).<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前系统时间，并提取天数</span></span><br><span class="line">    std::chrono::system_clock::time_point now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    _days = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::days&gt;(now.<span class="built_in">time_since_epoch</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置日志文件路径并设置输出文件流对象</span></span><br><span class="line">    _file_path = _dir_path + <span class="string">&quot;WebServer_&quot;</span> + <span class="built_in">get_format_time</span>(now, <span class="string">&quot;%Y-%m-%d_%H:%M:%S&quot;</span>) + <span class="string">&quot;.log&quot;</span>;</span><br><span class="line">    _file_output.<span class="built_in">open</span>(_file_path, std::ofstream::app);</span><br><span class="line">    <span class="keyword">if</span> (!_file_output) <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to open &#x27;&quot;</span> + _file_path + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用可变参模板和包扩展的方式格式化写入信息，可将任意类型的数据组合并格式化为一条日志消息。</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">log</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// 模板成员函数，将单个对象写入字符串输出流，将作为重载的可变参版本的递归终止条件</span></span><br><span class="line">        <span class="comment">// 即向文件输出流对象写入最后一个数据，并添加换行符表示该日志消息结束</span></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        <span class="function">std::ostringstream&amp; <span class="title">to_ostringstream</span><span class="params">(std::ostringstream &amp;os, <span class="type">const</span> T &amp;t)</span></span></span><br><span class="line"><span class="function">        </span>&#123; os &lt;&lt; t &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="keyword">return</span> os; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可变参模板，将任意类型的多个对象写入字符串输出流</span></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">        <span class="function">std::ostringstream&amp; <span class="title">to_ostringstream</span><span class="params">(std::ostringstream &amp;os,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> T &amp;t, <span class="type">const</span> Args &amp;...rest)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 可变参模板，以递归的方式将任意类型的多个对象写入字符串输出流</span></span><br><span class="line"><span class="comment">// 递归终止条件为参数包被分解为只剩一个参数的状态，此时调用非可变参版本的to_ostringstream</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">std::ostringstream&amp; <span class="title">log::to_ostringstream</span><span class="params">(std::ostringstream &amp;os,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> T &amp;t, <span class="type">const</span> Args &amp;...rest)</span> </span>&#123;</span><br><span class="line">    os &lt;&lt; t &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">to_ostringstream</span>(os, rest...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义四种日志级别，并根据写入方式进行同步或异步写入日志信息。</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 枚举类型，定义四种日志信息级别</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">LOG_LEVEL</span> &#123; DEBUG, INFO, WARN, ERROR &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">log</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// 异步写入日志信息</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">async_write_log</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 可变参模板，根据写入方式，向文件输出流对象同步/异步写入日志信息</span></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">write_log</span><span class="params">(LOG_LEVEL level, <span class="type">const</span> Args &amp;...rest)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 作为写线程的回调函数，用于异步写入日志信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log::async_write_log</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string message;</span><br><span class="line">    <span class="comment">// 从阻塞队列中取出日志信息并写入文件输出流对象</span></span><br><span class="line">    <span class="keyword">while</span> (_log_queue-&gt;<span class="built_in">pop</span>(message))  &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">        _file_output &lt;&lt; message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可变参模板，可设置日志信息级别，并将任意类型的多个对象组合成字符串形式的日志信息</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log::write_log</span><span class="params">(LOG_LEVEL level, <span class="type">const</span> Args &amp;...rest)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前系统时间，并提取天数</span></span><br><span class="line">    std::chrono::system_clock::time_point now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::chrono::days tmp_days = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::days&gt;(now.<span class="built_in">time_since_epoch</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若当前天数和先前设置的天数不同，或日志文件行数已经达到</span></span><br><span class="line">    <span class="comment">// 则刷新先前的缓冲区内容至日志文件，并创建新的日志文件</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">    ++_cnt_lines;</span><br><span class="line">    <span class="keyword">if</span> (tmp_days != _days || _cnt_lines &gt;= _max_lines) &#123;</span><br><span class="line">        <span class="comment">// 刷新缓冲区内容至日志文件</span></span><br><span class="line">        _file_output &lt;&lt; std::flush;</span><br><span class="line">        _file_output.<span class="built_in">close</span>();</span><br><span class="line">        <span class="comment">// 设置新日志文件路径并重置输出文件流对象</span></span><br><span class="line">        _file_path = _dir_path + <span class="string">&quot;WebServer_&quot;</span> + <span class="built_in">get_format_time</span>(now, <span class="string">&quot;%Y-%m-%d_%H:%M:%S&quot;</span>) + <span class="string">&quot;.log&quot;</span>;</span><br><span class="line">        _file_output.<span class="built_in">open</span>(_file_path, std::ofstream::app);</span><br><span class="line">        <span class="keyword">if</span> (!_file_output) <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to open &#x27;&quot;</span> + _file_path + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        _days = tmp_days;</span><br><span class="line">        _cnt_lines = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串输出流，用于暂存将要写入日志文件的日志消</span></span><br><span class="line">    std::ostringstream message;</span><br><span class="line">    <span class="comment">// 设置消息头中的时间部分</span></span><br><span class="line">    message &lt;&lt; <span class="built_in">get_format_time</span>(now) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="comment">// 设置消息头中的消息等级</span></span><br><span class="line">    <span class="keyword">switch</span> (level) &#123;</span><br><span class="line">        <span class="keyword">case</span> LOG_LEVEL::DEBUG:</span><br><span class="line">            message &lt;&lt; <span class="string">&quot;[DEBUG]: &quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LOG_LEVEL::INFO:</span><br><span class="line">            message &lt;&lt; <span class="string">&quot;[INFO]: &quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LOG_LEVEL::WARN:</span><br><span class="line">            message &lt;&lt; <span class="string">&quot;[WARN]: &quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LOG_LEVEL::ERROR:</span><br><span class="line">            message &lt;&lt; <span class="string">&quot;[ERROR]: &quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            message &lt;&lt; <span class="string">&quot;[INFO]: &quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化可变参模板，将任意类型的多个对象所组成的消息体写入字符串输出流</span></span><br><span class="line">    <span class="built_in">to_ostringstream</span>(message, rest...);</span><br><span class="line">    <span class="comment">// 若为异步写入，则将消息加入阻塞队列，否则为同步写入，则将消息直接输出到文件流</span></span><br><span class="line">    <span class="keyword">if</span> (_write_mode == _async_write) _log_queue-&gt;<span class="built_in">push</span>(message.<span class="built_in">str</span>());</span><br><span class="line">    <span class="keyword">else</span> &#123; lock.<span class="built_in">lock</span>(); _file_output &lt;&lt; message.<span class="built_in">str</span>(); lock.<span class="built_in">unlock</span>(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过宏函数提供日志写入的便捷方式</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 宏函数，使写入日志消息更加便捷</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_DEBUG(...) log::get_instance()-&gt;write_log(LOG_LEVEL::DEBUG, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO(...) log::get_instance()-&gt;write_log(LOG_LEVEL::INFO, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_WARN(...) log::get_instance()-&gt;write_log(LOG_LEVEL::WARN, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR(...) log::get_instance()-&gt;write_log(LOG_LEVEL::ERROR, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_FLUSH() log::get_instance()-&gt;flush();</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="Day5-HTTP连接实现"><a href="#Day5-HTTP连接实现" class="headerlink" title="Day5: HTTP连接实现"></a>Day5: HTTP连接实现</h2><ul>
<li><p>HTTP连接概念</p>
<ul>
<li>HTTP是请求&#x2F;应答式的，其报文分为请求报文和响应报文两种，每种报文都有特定的格式。其中，浏览器向服务器发送的是请求报文，服务器处理后返回给浏览器端的是响应报文。</li>
</ul>
</li>
<li><p>HTTP处理流程</p>
<ul>
<li>首先浏览器端发出HTTP连接请求，主线程创建HTTP对象用于接收请求并将数据读入缓冲区，再将处理请求的回调函数插入任务队列，工程线程从任务队列中取出任务并执行。</li>
<li>工作线程处理任务时，会调用http连接类中的<code>process_read</code>函数，通过主、从状态机解析请求报文。</li>
<li>当解析完成，则跳转到<code>exec_request</code>函数以生成响应报文，并由<code>process_write</code>写入缓冲区，返回给浏览器。</li>
</ul>
</li>
<li><p>http连接类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">http_connection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 请求文件的文件名大小</span></span><br><span class="line">        <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> FILE_NAME_SIZE = <span class="number">200</span>;</span><br><span class="line">        <span class="comment">// 读写缓冲区大小</span></span><br><span class="line">        <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> READ_BUFFER_SIZE = <span class="number">2048</span>;</span><br><span class="line">        <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> WRITE_BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">// 请求方法：GET、POST（本项目只用到了这两种）</span></span><br><span class="line">        <span class="keyword">enum class</span> <span class="title class_">REQUEST_METHOD</span> &#123; GET, POST &#125;;</span><br><span class="line">        <span class="comment">// http状态码：请求尚未完整、获得了完整请求、存在语法错误、服务器内部错误</span></span><br><span class="line">        <span class="comment">// 请求资源不存在、请求资源禁止访问、请求资源可以访问、关闭http连接</span></span><br><span class="line">        <span class="keyword">enum class</span> <span class="title class_">HTTP_CODE</span> &#123; NO_REQUEST, GET_REQUEST, BAD_REQUEST, INTERNAL_ERROR,</span><br><span class="line">            NO_RESOURCE, FORBIDDEN_REQUEST, FILE_REQUEST, CLOSED_CONNECTION &#125;;</span><br><span class="line">        <span class="comment">// 主状态机状态：检查请求行、检查请求头、检查请求数据</span></span><br><span class="line">        <span class="keyword">enum class</span> <span class="title class_">CHECK_STATUS</span> &#123; CHECK_REQUEST_LINE, CHECK_HEADER, CHECK_CONTENT &#125;;</span><br><span class="line">        <span class="comment">// 从状态机状态：成功解析完一行、存在语法错误、尚未成功解析完一行</span></span><br><span class="line">        <span class="keyword">enum class</span> <span class="title class_">LINE_STATUS</span> &#123; LINE_OK, LINE_BAD, LINE_OPEN &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> _epollfd; <span class="comment">// epoll对象的文件描述符</span></span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> _user_count; <span class="comment">// 连接的客户端的数量</span></span><br><span class="line">        MYSQL *_mysql; <span class="comment">// 数据库连接</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> _sockfd; <span class="comment">// 与客户端连接的文件描述符</span></span><br><span class="line">        sockaddr_in _address; <span class="comment">// 客户端的socket地址</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> _read_buf[READ_BUFFER_SIZE]; <span class="comment">// 读缓冲</span></span><br><span class="line">        <span class="type">int</span> _read_idx; <span class="comment">// 读缓冲区中最后一个字节数据的下一个位置</span></span><br><span class="line">        <span class="type">int</span> _checked_idx; <span class="comment">// 读缓冲区中当前正在读取的数据的位置</span></span><br><span class="line">        <span class="type">int</span> _start_line; <span class="comment">// 读缓冲区中已解析的字符个数</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> _write_buf[WRITE_BUFFER_SIZE]; <span class="comment">// 写缓冲区</span></span><br><span class="line">        <span class="type">int</span> _write_idx; <span class="comment">// 写缓冲区中已写入的字符个数</span></span><br><span class="line"></span><br><span class="line">        CHECK_STATUS _check_status; <span class="comment">// 主状态机的状态</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求行中的字段</span></span><br><span class="line">        REQUEST_METHOD _request_method; <span class="comment">// 请求方法</span></span><br><span class="line">        <span class="type">bool</span> _cgi; <span class="comment">// 请求方式是否为POST</span></span><br><span class="line">        <span class="type">char</span> *_url; <span class="comment">// 请求资源的url</span></span><br><span class="line">        <span class="type">char</span> *_version; <span class="comment">// http版本号</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求头中的字段</span></span><br><span class="line">        <span class="type">char</span> *_host; <span class="comment">// 服务器的域名</span></span><br><span class="line">        <span class="type">int</span> _content_length; <span class="comment">// 记录请求数据的长度，若为POST方式，则该值大于0</span></span><br><span class="line">        <span class="type">bool</span> _linger; <span class="comment">// 连接管理（长连接：keep-alive、短连接：close）</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> _real_file[FILE_NAME_SIZE]; <span class="comment">// 请求资源的文件路</span></span><br><span class="line">        <span class="type">char</span> *_file_address; <span class="comment">// 请求资源的文件所映射到的内存地址</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">stat</span> _file_stat; <span class="comment">// 记录所请求的资源文件的文件属性</span></span><br><span class="line">        <span class="comment">// iovec数组第一个元素指向写缓冲区，第二个指向资源文件所映射到的内存地址</span></span><br><span class="line">        <span class="comment">// 若请求的资源文件出错（不存在或无权访问），则只有第一个元素有效，并指向写缓冲区</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">iovec</span> _iv[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> _iv_count; <span class="comment">// 记录有效的iovec个数</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> *_user_info; <span class="comment">// 当请求方式为POST时，存放POST携带的数据（用户名和密码）</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> _bytes_sent; <span class="comment">// 已发送的字节数</span></span><br><span class="line">        <span class="type">int</span> _bytes_left; <span class="comment">// 剩余待发送的字节数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HTTP请求报文格式：由请求行、请求头部、空行和请求数据四部分组成</p>
<ul>
<li>请求行：三个字段，分别表示请求方式（GET&#x2F;POST），请求资源的URL，所使用的HTTP版本号。</li>
<li>请求头部：主要有三个字段，Host表示服务器域名、Content-Length表示报文所携带的请求数据（主体）的长度、Connection表示连接管理方式（长&#x2F;短连接）。</li>
<li>空行：请求报文即使没有请求数据，也必须有空行，用回车加换行<code>\r\n</code>表示。</li>
<li>请求数据：也叫请求主体，用于POST请求时，向服务器提供数据。</li>
</ul>
</li>
<li><p>请求报文解析流程：利用主从状态机进行逻辑转移，完成对请求行、请求头、请求数据的解析</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据主从状态机状态，通过循环来不停地解析请求报文中的数据</span></span><br><span class="line"><span class="function">http_connection::HTTP_CODE <span class="title">http_connection::process_read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化从状态机（成功解析完一行）和报文解析结果（请求尚未完整）</span></span><br><span class="line">    LINE_STATUS line_status = LINE_STATUS::LINE_OK;</span><br><span class="line">    HTTP_CODE ret = HTTP_CODE::NO_REQUEST;</span><br><span class="line">    <span class="type">char</span> *text = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环条件1: 正在检测请求数据内容（POST才有），由于GET请求中的报文每行都以\r\n为结束</span></span><br><span class="line">    <span class="comment">// 而POST请求数据无任何结束符，所有不能通过从状态机，而应该通过主状态机判断</span></span><br><span class="line">    <span class="comment">// 若请求数据全部解析完毕，则表明整个报文也解析完毕，但主状态仍为CHECK_STATUS::CHECK_CONTENT</span></span><br><span class="line">    <span class="comment">// 所以需要从状态机辅助判断，当全部解析完毕，就将从状态设置为LINE_STATUS::LINE_OPEN以退出循环</span></span><br><span class="line">    <span class="comment">// 循环条件2: 正在检测请求行或请求头，且每次进入循环前，从状态机都已成功解析完一行</span></span><br><span class="line">    <span class="comment">// 即读取完了一行，且将结束符从\r\n替换为了\0\0</span></span><br><span class="line">    <span class="keyword">while</span> ((_check_status == CHECK_STATUS::CHECK_CONTENT</span><br><span class="line">                &amp;&amp; line_status == LINE_STATUS::LINE_OK)</span><br><span class="line">            || ((line_status = <span class="built_in">parse_line</span>()) == LINE_STATUS::LINE_OK)) &#123;</span><br><span class="line">        <span class="comment">// 获取将要解析的行的起始位置</span></span><br><span class="line">        text = _read_buf + _start_line;</span><br><span class="line">        _start_line = _checked_idx;</span><br><span class="line">        <span class="comment">// 从状态机的三种状态转移逻辑</span></span><br><span class="line">        <span class="keyword">switch</span> (_check_status) &#123;</span><br><span class="line">            <span class="comment">// 表示正在解析请求行内容</span></span><br><span class="line">            <span class="keyword">case</span> CHECK_STATUS::CHECK_REQUEST_LINE:</span><br><span class="line">                &#123;</span><br><span class="line">                    ret = <span class="built_in">parse_request_line</span>(text);</span><br><span class="line">                    <span class="keyword">if</span> (ret == HTTP_CODE::BAD_REQUEST) <span class="keyword">return</span> HTTP_CODE::BAD_REQUEST;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">// 表示正在解析请求头内容</span></span><br><span class="line">            <span class="keyword">case</span> CHECK_STATUS::CHECK_HEADER:</span><br><span class="line">                &#123;</span><br><span class="line">                    ret = <span class="built_in">parse_headers</span>(text);</span><br><span class="line">                    <span class="keyword">if</span> (ret == HTTP_CODE::BAD_REQUEST) <span class="keyword">return</span> HTTP_CODE::BAD_REQUEST;</span><br><span class="line">                    <span class="comment">// 由于GET请求无请求数据，所以解析完请求头后可直接执行响应函数</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (ret == HTTP_CODE::GET_REQUEST) <span class="keyword">return</span> <span class="built_in">exec_request</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">// 表示正在解析请求数据内容（请求方法为POST时）</span></span><br><span class="line">            <span class="keyword">case</span> CHECK_STATUS::CHECK_CONTENT:</span><br><span class="line">                &#123;</span><br><span class="line">                    ret = <span class="built_in">parse_content</span>(text);</span><br><span class="line">                    <span class="comment">// 若完整解析了POST的请求数据，则表示报文已全部解析完毕，可执行响应函数</span></span><br><span class="line">                    <span class="keyword">if</span> (ret == HTTP_CODE::GET_REQUEST) <span class="keyword">return</span> <span class="built_in">exec_request</span>();</span><br><span class="line">                    <span class="comment">// 将从状态设置为LINE_STATUS::LINE_OPEN，以免再次进入循环</span></span><br><span class="line">                    line_status = LINE_STATUS::LINE_OPEN;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">// 若三种状态都不符，则表示出现服务器内部错误，一般不会触发</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> HTTP_CODE::INTERNAL_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 表示整个http请求尚未完整，需要继续接收请求数据以供解析</span></span><br><span class="line">    <span class="keyword">return</span> HTTP_CODE::NO_REQUEST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从状态机：负责从读缓冲区中读取数据，将每行数据末尾的<code>\r\n</code>替换为<code>\0\0</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从状态机：用于解析一行数据，返回LINE_STATUS值，表示解析结果</span></span><br><span class="line"><span class="function">http_connection::LINE_STATUS <span class="title">http_connection::parse_line</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> tmp; _checked_idx &lt; _read_idx; ++_checked_idx) &#123;</span><br><span class="line">        tmp = _read_buf[_checked_idx];</span><br><span class="line">        <span class="comment">// 若当前为\r字符，则可能会读取到完整的行</span></span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="string">&#x27;\r&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 若下一个字符到达了读缓冲区的末尾，则表示接收尚未完整，需继续接收</span></span><br><span class="line">            <span class="keyword">if</span> ((_checked_idx + <span class="number">1</span>) == _read_idx) <span class="keyword">return</span> LINE_STATUS::LINE_OPEN;</span><br><span class="line">            <span class="comment">// 若下一个字符为\n，则表明接收到了完整的行，并将\r\n改为\0\0表示解析成功</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (_read_buf[_checked_idx + <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                _read_buf[_checked_idx++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                _read_buf[_checked_idx++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">return</span> LINE_STATUS::LINE_OK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若都不符合，则返回语法错误</span></span><br><span class="line">            <span class="keyword">return</span> LINE_STATUS::LINE_BAD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若当前字符为\n，也可能会读取到完整的行</span></span><br><span class="line">        <span class="comment">// 即上次读到\r就到了读缓冲区的末尾，没有接收完整</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tmp == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 前一个字符为\r，则表示接收完整</span></span><br><span class="line">            <span class="keyword">if</span> (_checked_idx &gt; <span class="number">1</span> &amp;&amp; _read_buf[_checked_idx - <span class="number">1</span>] == <span class="string">&#x27;\r&#x27;</span>) &#123;</span><br><span class="line">                _read_buf[_checked_idx - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                _read_buf[_checked_idx++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">return</span> LINE_STATUS::LINE_OK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> LINE_STATUS::LINE_BAD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尚未找到\r\n，则需要继续接收</span></span><br><span class="line">    <span class="keyword">return</span> LINE_STATUS::LINE_OPEN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>主状态机解析请求行：获取请求方法（GET&#x2F;POST）、URL、HTTP版本号</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">http_connection::HTTP_CODE <span class="title">http_connection::parse_request_line</span><span class="params">(<span class="type">char</span> *text)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 请求行内容中的字段以空格或\t分隔，找到第一个空格或\t，则表示找到了url</span></span><br><span class="line">    _url = <span class="built_in">strpbrk</span>(text, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">    <span class="comment">// 若无空格或\t，则请求报文有语法错误</span></span><br><span class="line">    <span class="keyword">if</span> (!_url) <span class="keyword">return</span> HTTP_CODE::BAD_REQUEST;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将该位置改为\0，用于将前面的字段取出（请求方法）</span></span><br><span class="line">    *_url++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="comment">// 解析请求方法字段，本项目只用到了GET和POST</span></span><br><span class="line">    <span class="type">char</span> *method = text;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(method, <span class="string">&quot;GET&quot;</span>) == <span class="number">0</span>) _request_method = REQUEST_METHOD::GET;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(method, <span class="string">&quot;POST&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        _request_method = REQUEST_METHOD::POST;</span><br><span class="line">        _cgi = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> HTTP_CODE::BAD_REQUEST;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向后移动，跳过空格或\t，以找到http版本号位置</span></span><br><span class="line">    _url += <span class="built_in">strspn</span>(_url, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">    <span class="comment">// 解析版本号字段（仅支持http1.1），与上面的操作类似</span></span><br><span class="line">    _version = <span class="built_in">strpbrk</span>(_url, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!_version) <span class="keyword">return</span> HTTP_CODE::BAD_REQUEST;</span><br><span class="line">    *_version++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    _version += <span class="built_in">strspn</span>(_version, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(_version, <span class="string">&quot;HTTP/1.1&quot;</span>) != <span class="number">0</span>) <span class="keyword">return</span> HTTP_CODE::BAD_REQUEST;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理url中携带http(s)://的情况</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(_url, <span class="string">&quot;http://&quot;</span>, <span class="number">7</span>) == <span class="number">0</span>) &#123; _url += <span class="number">7</span>; _url = <span class="built_in">strchr</span>(_url, <span class="string">&#x27;/&#x27;</span>); &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(_url, <span class="string">&quot;https://&quot;</span>, <span class="number">8</span>) == <span class="number">0</span>) &#123; _url += <span class="number">8</span>; _url = <span class="built_in">strchr</span>(_url, <span class="string">&#x27;/&#x27;</span>); &#125;</span><br><span class="line">    <span class="comment">// url中无上述两种符号，直接是单独的/或//后接访问资源，则请求报文有语法错误</span></span><br><span class="line">    <span class="keyword">if</span> (!_url || _url[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>) <span class="keyword">return</span> HTTP_CODE::BAD_REQUEST;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当url为/时，默认显示校验界面</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(_url) == <span class="number">1</span>) <span class="built_in">strcat</span>(_url, <span class="string">&quot;judge.html&quot;</span>);</span><br><span class="line">    _check_status = CHECK_STATUS::CHECK_HEADER;</span><br><span class="line">    <span class="keyword">return</span> HTTP_CODE::NO_REQUEST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>主状态机解析请求头或空行：若为请求头，则解析Host服务器域名字段、Connection连接管理字段、Content-Length请求数据长度字段；若为空行，需要判断先前解析请求头过程中已得到的Content-Length字段是否为<code>0</code>，为<code>0</code>则是GET，且无需再解析，否则为POST。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">http_connection::HTTP_CODE <span class="title">http_connection::parse_headers</span><span class="params">(<span class="type">char</span> *text)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是空行还是请求头，由于每次调用前，从状态机都已完成了对一行的解析</span></span><br><span class="line">    <span class="comment">// 因此若为空行\r\n，则必定已经被替换为了\0\0</span></span><br><span class="line">    <span class="keyword">if</span> (text[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 请求方法字段为POST才会有请求数据，此时_content_length已在解析请求头的过程中完成设置</span></span><br><span class="line">        <span class="keyword">if</span> (_content_length != <span class="number">0</span>) &#123;</span><br><span class="line">            _check_status = CHECK_STATUS::CHECK_CONTENT;</span><br><span class="line">            <span class="keyword">return</span> HTTP_CODE::NO_REQUEST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则为GET请求，表明请求报文已经全部解析完毕</span></span><br><span class="line">        <span class="keyword">return</span> HTTP_CODE::GET_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若不为空行，则解析请求头</span></span><br><span class="line">    <span class="comment">// 解析请求头中的连接管理字段（keep-alive长连接、close短连接）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(text, <span class="string">&quot;Connection:&quot;</span>, <span class="number">11</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        text += <span class="number">11</span>; text += <span class="built_in">strspn</span>(text, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(text, <span class="string">&quot;keep-alive&quot;</span>) == <span class="number">0</span>) _linger = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解析请求头中的请求数据长度字段</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(text, <span class="string">&quot;Content-length:&quot;</span>, <span class="number">15</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        text += <span class="number">15</span>; text += <span class="built_in">strspn</span>(text, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">        _content_length = <span class="built_in">atol</span>(text);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解析请求头中的服务器域名字段</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(text, <span class="string">&quot;Host:&quot;</span>, <span class="number">5</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        text += <span class="number">5</span>; text += <span class="built_in">strspn</span>(text, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">        _host = text;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;oop! unknow header: &quot;</span>, text);</span><br><span class="line">        log::<span class="built_in">get_instance</span>()-&gt;<span class="built_in">flush</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> HTTP_CODE::NO_REQUEST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>主状态机解析请求数据（请求主体）：仅当请求方法为POST时才会调用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">http_connection::HTTP_CODE <span class="title">http_connection::parse_content</span><span class="params">(<span class="type">char</span> *text)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断读缓冲区是否已经读取了完整的请求数据</span></span><br><span class="line">    <span class="keyword">if</span> (_read_idx &gt;= (_content_length + _checked_idx)) &#123;</span><br><span class="line">        text[_content_length] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="comment">// 对于POST请求，只能处理其携带用户名和密码的情况</span></span><br><span class="line">        _user_info = text;</span><br><span class="line">        <span class="keyword">return</span> HTTP_CODE::GET_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> HTTP_CODE::NO_REQUEST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HTTP响应报文格式：由状态行、消息报头、空行、响应正文四部分组成</p>
<ul>
<li>状态行：由HTTP版本号、状态码、状态消息三个字段组成。</li>
<li>消息报头：主要有两个字段，Content-Length表示响应正文的长度、Connection表示连接管理方式（长&#x2F;短连接），以及一些其他字段，如Date日期等。</li>
<li>空行：消息报头后面必须接空行，用回车加换行<code>\r\n</code>表示。</li>
<li>响应正文：服务器返回给客户端的文本数据（html），由浏览器完成解析。</li>
</ul>
</li>
<li><p>响应报文写入流程：按照响应报文格式，依次将每部分内容写入缓冲区即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">http_connection</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// 生成响应报文的状态行（http版本号、状态码、状态消息）</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">add_status_line</span><span class="params">(<span class="type">int</span> status, <span class="type">const</span> <span class="type">char</span> *title)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">add_response</span>(<span class="string">&quot;%s %d %s\r\n&quot;</span>, <span class="string">&quot;HTTP/1.1&quot;</span>, status, title);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成响应报文的消息头（content-length响应正文长度、connection连接管理）</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">add_headers</span><span class="params">(<span class="type">int</span> content_length)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">add_response</span>(<span class="string">&quot;Content-Length:%d\r\nConnection:%s\r\n&quot;</span>,</span><br><span class="line">                    content_length, (_linger ? <span class="string">&quot;keep-alive&quot;</span> : <span class="string">&quot;close&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成响应报文的空行</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">add_blank_line</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">add_response</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;\r\n&quot;</span>); &#125;</span><br><span class="line">        <span class="comment">// 生成响应报文的响应正文</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">add_content</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *content)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">add_response</span>(<span class="string">&quot;%s&quot;</span>, content); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据http状态码向写缓冲区中写入响应报文</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_connection::process_write</span><span class="params">(HTTP_CODE ret)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">        <span class="comment">// 服务器内部出现错误</span></span><br><span class="line">        <span class="keyword">case</span> HTTP_CODE::INTERNAL_ERROR:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">add_status_line</span>(<span class="number">500</span>, error_500_title);</span><br><span class="line">                <span class="built_in">add_headers</span>(<span class="built_in">strlen</span>(error_500_form));</span><br><span class="line">                <span class="built_in">add_blank_line</span>();</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">add_content</span>(error_500_form)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 请求报文存在语法错误</span></span><br><span class="line">        <span class="keyword">case</span> HTTP_CODE::BAD_REQUEST:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">add_status_line</span>(<span class="number">404</span>, error_404_title);</span><br><span class="line">                <span class="built_in">add_headers</span>(<span class="built_in">strlen</span>(error_404_form));</span><br><span class="line">                <span class="built_in">add_blank_line</span>();</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">add_content</span>(error_404_form)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 无权访问请求资源</span></span><br><span class="line">        <span class="keyword">case</span> HTTP_CODE::FORBIDDEN_REQUEST:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">add_status_line</span>(<span class="number">403</span>, error_403_title);</span><br><span class="line">                <span class="built_in">add_headers</span>(<span class="built_in">strlen</span>(error_403_form));</span><br><span class="line">                <span class="built_in">add_blank_line</span>();</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">add_content</span>(error_403_form)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 资源文件存在且有权访问</span></span><br><span class="line">        <span class="keyword">case</span> HTTP_CODE::FILE_REQUEST:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">add_status_line</span>(<span class="number">200</span>, ok_200_title);</span><br><span class="line">                <span class="keyword">if</span> (_file_stat.st_size != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">add_headers</span>(_file_stat.st_size);</span><br><span class="line">                    <span class="built_in">add_blank_line</span>();</span><br><span class="line">                    <span class="comment">// 将iovec中第一个元素设置为指向写缓冲区的指针</span></span><br><span class="line">                    _iv[<span class="number">0</span>].iov_base = _write_buf;</span><br><span class="line">                    _iv[<span class="number">0</span>].iov_len = _write_idx;</span><br><span class="line">                    <span class="comment">// 将iovec中第二个元素设置为资源文件所映射到的内存地址</span></span><br><span class="line">                    _iv[<span class="number">1</span>].iov_base = _file_address;</span><br><span class="line">                    _iv[<span class="number">1</span>].iov_len = _file_stat.st_size;</span><br><span class="line">                    <span class="comment">// 设置iovec的有效元素个数为2</span></span><br><span class="line">                    _iv_count = <span class="number">2</span>;</span><br><span class="line">                    <span class="comment">// 设置待发送的字节数为响应报文的状态行、消息头、空行</span></span><br><span class="line">                    <span class="comment">// 以及响应正文（资源文件）的总和</span></span><br><span class="line">                    _bytes_left = _write_idx + _file_stat.st_size;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 若资源文件的大小为0，则返回空白的html文件</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="type">char</span> *ok_string = <span class="string">&quot;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class="line">                    <span class="built_in">add_headers</span>(<span class="built_in">strlen</span>(ok_string));</span><br><span class="line">                    <span class="built_in">add_blank_line</span>();</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">add_content</span>(ok_string)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 除了HTTP_CODE::FILE_REQUEST，其余状态都不会设置资源文件到内存的映射</span></span><br><span class="line">    <span class="comment">// 所以无需设置iovec的第二个元素，只需将iovec第一个元素设置为指向写缓冲区即可</span></span><br><span class="line">    _iv[<span class="number">0</span>].iov_base = _write_buf;</span><br><span class="line">    _iv[<span class="number">0</span>].iov_len = _write_idx;</span><br><span class="line">    <span class="comment">// 设置iovec的有效元素个数为1</span></span><br><span class="line">    _iv_count = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 设置待发送的字节数为响应报文的状态行、消息头、空行的总和（无响应正文，即资源文件）</span></span><br><span class="line">    _bytes_left = _write_idx;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++轻量级多线程Web服务器（上篇）</title>
    <url>/2023/07/27/Project/WebServer1/</url>
    <content><![CDATA[<span id="more"></span>

<p>本项目地址：<a href="https://github.com/lijiang99/WebServer">https://github.com/lijiang99/WebServer</a></p>
<p>参考资料：<a href="https://dark-wind.github.io/books/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.pdf">《Linux高性能服务器编程》</a>、<a href="https://github.com/qinguoyi/TinyWebServer/tree/raw_version">TinyWebServer</a>、<a href="https://github.com/markparticle/WebServer">WebServer（C++版）</a></p>
<h2 id="Day1-运行项目"><a href="#Day1-运行项目" class="headerlink" title="Day1: 运行项目"></a>Day1: 运行项目</h2><ul>
<li><p>MySQL安装并修改密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装mysql</span></span><br><span class="line">sudo apt install mysql-server mysql-client</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看debian-sys-maint的密码</span></span><br><span class="line">sudo cat /etc/mysql/debian.cnf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过debian-sys-maint登录</span></span><br><span class="line">mysql -u debian-sys-maint -p</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改root用户的密码</span></span><br><span class="line">use mysql;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改mysql密码认证方式为本地认证</span></span><br><span class="line">UPDATE user SET plugin=&quot;mysql_native_password&quot; WHERE user=&quot;root&quot;;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先把密码改为空（也不知道为什么，但不这么干就一直失败）</span></span><br><span class="line">UPDATE user SET authentication_string=&quot;&quot; WHERE user=&quot;root&quot;;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改成想要的密码</span></span><br><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">刷新权限并退出</span></span><br><span class="line">flush privileges;</span><br><span class="line">exit</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启mysql</span></span><br><span class="line">sudo service mysql restart</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以root登录</span></span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建新的数据库和数据表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 创建新的数据库和数据表</span><br><span class="line"><span class="keyword">create</span> database tiny_web_server;</span><br><span class="line">USE tiny_web_server;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span>(</span><br><span class="line">    username <span class="type">char</span>(<span class="number">50</span>) <span class="keyword">NULL</span>,</span><br><span class="line">    passwd <span class="type">char</span>(<span class="number">50</span>) <span class="keyword">NULL</span></span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"># 向数据表中添加数据</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span>(username, passwd) <span class="keyword">VALUES</span>(<span class="string">&#x27;bd7xzz&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>);</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置信息</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp中的数据库初始化信息</span></span><br><span class="line"><span class="comment">// 修改MySQL服务器登录名和密码，并指定要用到的database</span></span><br><span class="line">connPool-&gt;<span class="built_in">init</span>(<span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>, <span class="string">&quot;tiny_web_server&quot;</span>, <span class="number">3306</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改http_conn.cpp中的root路径</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* doc_root=<span class="string">&quot;../root&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译构建</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装mysql链接库</span></span><br><span class="line">sudo apt install libmysqlclient-dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成server</span></span><br><span class="line">make server</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动server</span></span><br><span class="line">./server port</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">浏览器端</span></span><br><span class="line">localhost:port</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">压力测试（并发连接数10500，访问时长5s）</span></span><br><span class="line">./webbench -c 10500 -t 5 http://localhost:port/</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Day2-连接池实现"><a href="#Day2-连接池实现" class="headerlink" title="Day2: 连接池实现"></a>Day2: 连接池实现</h1><ul>
<li><p>连接池概念</p>
<ul>
<li>若系统需频繁访问数据库，则需频繁创建和断开数据库连接，但创建连接很耗时且有安全隐患。</li>
<li>程序初始化时，集中创建多个数据库连接形成连接池并集中管理，供程序使用，可保证较快的数据库读写速度，也更安全。</li>
<li>池可以看作资源的容器，流程是工作线程从连接池中取一个连接，访问数据库，访问结束后将连接交还连接池。</li>
</ul>
</li>
<li><p>连接池创建（单例模式–懒汉式创建连接池）</p>
<ul>
<li><p>原项目</p>
<ul>
<li>连接池的拷贝操作未显示定义或声明为私有，编译器会生成默认版本，因此该单例模式有漏洞。</li>
<li>基于懒汉式并使用局部静态变量创建连接池（但该方式在C++11之后才是线程安全的）  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">connection_pool* <span class="title">connection_pool::GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> connection_pool connPool;</span><br><span class="line">    <span class="keyword">return</span> &amp;connPool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>本项目改进 </p>
<ul>
<li>将构造函数和拷贝操作显示声明为私有，并利用<code>delete</code>关键字声明拷贝操作，以阻止编译器默认合成。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">connection_pool</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">connection_pool</span>();</span><br><span class="line">        <span class="built_in">connection_pool</span>(<span class="type">const</span> connection_pool&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">        <span class="function">connection_pool&amp; <span class="title">operator</span><span class="params">(<span class="type">const</span> connection_pool&amp; rhs)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>连接池初始化</p>
<ul>
<li><p>原项目</p>
<ul>
<li>定义了额外的<code>init</code>函数以供用户在类外修改连接池的内部数据成员</li>
<li>但如果用户多次调用<code>init</code>函数怎么办？<code>init</code>函数并未考虑在多次调用的情况下，内部链表的状态变化（可能需要先销毁再重新分配），那么函数名就与其实际工作不符。</li>
<li>个人觉得应初始化有且仅有一次，若需修改连接池内部数据则应提供额外接口，并在实现时考虑链表的状态问题。</li>
</ul>
</li>
<li><p>本项目改进</p>
<ul>
<li><p>数据成员</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::atomic_bool init_status_type;</span><br><span class="line">    std::string _host; <span class="comment">// 主机地址</span></span><br><span class="line">    std::string _user; <span class="comment">// 数据库用户名</span></span><br><span class="line">    std::<span class="type">size_t</span> _port; <span class="comment">// 数据库端口号</span></span><br><span class="line">    std::string _password; <span class="comment">// 数据库密码</span></span><br><span class="line">    std::string _database; <span class="comment">// 所使用的数据库名</span></span><br><span class="line">    std::<span class="type">size_t</span> _max_conn; <span class="comment">// 最大连接数</span></span><br><span class="line">    <span class="comment">// 原子变量，用于判断连接池是否已经初始化</span></span><br><span class="line">    init_status_type _init_status;</span><br><span class="line">    std::mutex _mutex; <span class="comment">// 互斥锁</span></span><br><span class="line">    <span class="type">sem_t</span> _sem; <span class="comment">// 信号量</span></span><br><span class="line">    <span class="comment">// 使用以双向链表为底层数据结构的队列构造连接池</span></span><br><span class="line">    std::queue&lt;MYSQL*, std::list&lt;MYSQL*&gt;&gt; _conn_queue;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数中将<code>_init_status</code>状态置为<code>false</code>表示未初始化，<code>init</code>函数中根据该状态判断是否执行初始化。</p>
</li>
</ul>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数为私有，类内定义，默认为inline</span></span><br><span class="line"><span class="built_in">connection_pool</span>() : _init_status(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化数据库连接池信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">connection_pool::init</span><span class="params">(<span class="type">const</span> std::string&amp; host, <span class="type">const</span> std::string&amp; user, std::<span class="type">size_t</span> port,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::string&amp; password, <span class="type">const</span> std::string&amp; database, std::<span class="type">size_t</span> max_conn)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> expected = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!_init_status.<span class="built_in">compare_exchange_weak</span>(expected, <span class="literal">true</span>))</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;connection pool already initialized&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数据库信息</span></span><br><span class="line">    _host = host; _user = user; _port = port;</span><br><span class="line">    _password = password; _database = database; _max_conn = max_conn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据最大连接数预分配连接并添加到队列中</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _max_conn; ++i) &#123;</span><br><span class="line">        MYSQL* conn = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 初始化连接</span></span><br><span class="line">        conn = <span class="built_in">mysql_init</span>(conn);</span><br><span class="line">        <span class="keyword">if</span> (conn == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to initialize database connection&quot;</span>);</span><br><span class="line">        <span class="comment">// 建立一条实际的数据库连接</span></span><br><span class="line">        conn = <span class="built_in">mysql_real_connect</span>(conn, _host.<span class="built_in">c_str</span>(), _user.<span class="built_in">c_str</span>(),</span><br><span class="line">                _password.<span class="built_in">c_str</span>(), _database.<span class="built_in">c_str</span>(), _port, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (conn == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to establish database connection&quot;</span>);</span><br><span class="line">        <span class="comment">// 向连接池中加入一条连接</span></span><br><span class="line">        _conn_queue.<span class="built_in">push</span>(conn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 信号量初始化为最大连接数</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;_sem, <span class="number">0</span>, _max_conn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意其中对于初始化状态判断部分的代码</li>
</ul>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用原子变量判断初始化状态，只允许初始化一次，禁止重复初始化</span></span><br><span class="line"><span class="comment">// compare_exchange_weak为CAS(compare and swap)操作</span></span><br><span class="line"><span class="comment">// 若当前_init_status == expected，表示尚未初始化，则将true赋给_init_status，并返回true</span></span><br><span class="line"><span class="comment">// 若当前_init_status != expected，表示已初始化过，则将_init_status赋给expected，并返回false</span></span><br><span class="line"><span class="type">bool</span> expected = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!_init_status.<span class="built_in">compare_exchange_weak</span>(expected, <span class="literal">true</span>))</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;connection pool already initialized&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能将其改写成如下形式，即使原子变量读写都互斥，在理论上下面的代码仍会出现问题</span></span><br><span class="line"><span class="comment">// 如线程A读到_init_status为false，则解锁读操作继续向下执行，此时线程B就可以读_init_status了</span></span><br><span class="line"><span class="comment">// 那么此时线程B的读（读到_init_status为true）可能在线程A的写（将_init_status改为false）前完成</span></span><br><span class="line"><span class="comment">// 那么线程B也会继续向下执行，这就造成线程A和线程B都对数据库连接池初始化了一遍，违背了init设计的初衷</span></span><br><span class="line"><span class="comment">// 因此必须使用上面的CAS操作，将整个条件判断的过程都变为原子操作，且在条件判断过程中覆写_init_status</span></span><br><span class="line"><span class="keyword">if</span> (_init_status == <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;connection pool already initialized&quot;</span>);</span><br><span class="line">_init_status = <span class="literal">true</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>连接池接口</p>
<ul>
<li><p>获取可用连接<code>get_connection()</code></p>
<ul>
<li>信号量减<code>1</code>，相当于P操作，为<code>0</code>则阻塞等待可用连接</li>
<li>取链表首元素作为可用连接</li>
</ul>
</li>
<li><p>释放当前连接<code>put_connection(MYSQL* conn)</code></p>
<ul>
<li>将连接作为尾元素重新加入链表</li>
<li>信号量加<code>1</code>，相当于V操作</li>
</ul>
</li>
<li><p>销毁连接池（供析构函数内部使用）<code>destroy()</code></p>
<ul>
<li>遍历链表，关闭所有连接后，清空链表</li>
</ul>
</li>
</ul>
</li>
<li><p><code>RAII</code>机制管理连接资源</p>
<ul>
<li>构造函数中，通过指向连接池的指针来分配连接。</li>
<li>析构函数中，通过指向连接池的指针来释放连接。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sql_connection</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        MYSQL* _conn;</span><br><span class="line">        connection_pool* _conn_pool;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 通过指向连接池的指针来分配连接，并用返回的连接初始化_conn</span></span><br><span class="line">        <span class="comment">// 同时为修改传入参数，需传递指针型参数，而连接本身也是指针</span></span><br><span class="line">        <span class="comment">// 所以形参类型应该为二级指针</span></span><br><span class="line">        <span class="built_in">sql_connection</span>(MYSQL** sql, connection_pool* conn_pool) &#123;</span><br><span class="line">            *sql = conn_pool-&gt;<span class="built_in">get_connection</span>();</span><br><span class="line">            _conn = *sql;</span><br><span class="line">            _conn_pool = conn_pool</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过指向连接池的指针来释放所管理的连接</span></span><br><span class="line">        ~<span class="built_in">sql_connection</span>() &#123; _conn_pool-&gt;<span class="built_in">put_connection</span>(_conn); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="Day3-线程池实现"><a href="#Day3-线程池实现" class="headerlink" title="Day3: 线程池实现"></a>Day3: 线程池实现</h1><ul>
<li><p>线程池概念</p>
<ul>
<li>线程是轻量级的进程，执行效率和进程差不多，但消耗的系统资源更少，但频繁创建线程依然会降低效率。</li>
<li>线程池可实现线程复用，即执行完一个任务，并不会被销毁，而是继续执行其他任务。</li>
</ul>
</li>
<li><p>线程池方案</p>
<ul>
<li>采用半同步&#x2F;半反应堆的并发编程模式，主线程为处理IO事件的异步线程，工作线程为同步线程。</li>
<li>主线程监听到客户请求，就将其封装成任务对象并插入请求队列，再通知工作线程，工作线程从请求队列拉取任务并执行。</li>
</ul>
</li>
<li><p>线程池实现</p>
<ul>
<li><p>原项目</p>
<ul>
<li>定义为模板类，请求队列元素为指向模板类型的指针，且将工作线程的回调函数分离为<code>worker</code>和<code>run</code>。<code>worker</code>调用<code>run</code>，但<code>run</code>在内部需要通过指向模板类型（实例化为<code>http_conn</code>）指针来调用实际工作的函数（<code>process</code>），这就要求实例化时所提供的类，必须含有<code>process</code>成员函数，感觉耦合度过高。</li>
<li>定义了线程池数组，个人感觉根据在初始化时根据线程数创建线程即可，没必要额外定义。</li>
<li>使用信号量来设计生产者和消费者模型，且当超出最大请求数时就拒绝请求，感觉不合理。</li>
<li>以<code>deque</code>为底层的<code>queue</code>来实现请求队列，<code>deque</code>支持随机访问但浪费空间，且队列并无随机访问的要求（C++版）。</li>
<li>未定义最大请求数，那么请求会一直添加到请求队列中，浪费内存且拖慢效率（C++版）。</li>
</ul>
</li>
<li><p>本项目改进</p>
<ul>
<li><p>定义为模板类，请求队列元素类型为模板类型的仿函数（<code>function&lt;Callback&gt;</code>），因此线程池实例化时，可以接受任意类型的函数对象，且工作线程的任务全部由<code>worker</code>函数内部调用仿函数（请求队列元素）完成，从而实现解耦。并以<code>list</code>为底层的<code>queue</code>来实现请求队列，提高空间利用率。 </p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">bool</span> _thread_pool_status_type;</span><br><span class="line"><span class="type">const</span> _thread_pool_status_type _pool_startup = <span class="literal">true</span>;</span><br><span class="line"><span class="type">const</span> _thread_pool_status_type _pool_shutdown = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Callback&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thread_pool</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">typedef</span> _thread_pool_status_type pool_status_type;</span><br><span class="line">        <span class="comment">// 任务类型为仿函数对象（回调函数）</span></span><br><span class="line">        <span class="keyword">typedef</span> std::function&lt;Callback&gt; task_type;</span><br><span class="line">        <span class="comment">// 请求队列类型，以双向链表为底层容器的队列，每个元素均表示一个任务</span></span><br><span class="line">        <span class="keyword">typedef</span> std::queue&lt;task_type, std::list&lt;task_type&gt;&gt; task_queue_type;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 线程池状态（打开/关闭）</span></span><br><span class="line">        pool_status_type _pool_status;</span><br><span class="line">        <span class="comment">// 线程池中线程数量</span></span><br><span class="line">        std::<span class="type">size_t</span> _thread_number;</span><br><span class="line">        <span class="comment">// 请求队列允许的最大请求数</span></span><br><span class="line">        std::<span class="type">size_t</span> _max_requests;</span><br><span class="line">        <span class="comment">// 指向请求队列的指针，队列中元素即工作线程需要竞争的共享资源</span></span><br><span class="line">        task_queue_type* _task_queue;</span><br><span class="line">        <span class="comment">// 保护请求队列的互斥锁</span></span><br><span class="line">        std::mutex _mutex;</span><br><span class="line">        <span class="comment">// 用于生产者/消费者（工作线程）模型的条件变量，需要搭配互斥锁一起使用</span></span><br><span class="line">        std::condition_variable _cond_producer;</span><br><span class="line">        std::condition_variable _cond_consumer;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>未定义线程池数组，而是在构造函数中根据线程数量来创建线程。</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数，初始化线程池信息，并创建工作线程</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Callback&gt;</span><br><span class="line">thread_pool&lt;Callback&gt;::<span class="built_in">thread_pool</span>(<span class="type">int</span> thread_num, <span class="type">int</span> max_requests) : _pool_status(_pool_startup) &#123;</span><br><span class="line">    <span class="comment">// 判断线程数和最大请求数是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (_thread_number &lt;= <span class="number">0</span> || _max_requests &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;invalid number of threads or requests&quot;</span>);</span><br><span class="line">    <span class="comment">// 分配请求队列，默认初始化为空队列</span></span><br><span class="line">    <span class="keyword">if</span> (!(_task_queue = <span class="keyword">new</span> <span class="built_in">task_queue_type</span>()))</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to allocate memory for task queue&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    _thread_number = <span class="built_in">static_cast</span>&lt;std::<span class="type">size_t</span>&gt;(thread_number);</span><br><span class="line">    _max_requests = <span class="built_in">static_cast</span>&lt;std::<span class="type">size_t</span>&gt;(max_requests);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建工作线程，并将工作线程与主线程分离</span></span><br><span class="line">    <span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _thread_number; ++i) &#123;</span><br><span class="line">        <span class="comment">// 使用成员函数作为工作线程的回调函数需额外传递this指针</span></span><br><span class="line">        std::<span class="built_in">thread</span>(&amp;thread_pool::worker, <span class="keyword">this</span>).<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用条件变量来设计生产者（主线程<code>add_task</code>）&#x2F;消费者（工作线程<code>worker</code>）模型，且当超出最大请求数不会拒绝请求，而是阻塞主线程以待工作线程处理任务。若工作线程竞争到了任务并为请求队列腾出了空间，那么此时主线程解除阻塞并将任务加入请求队列。</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向请求队列中添加任务，右值引用用于模板转发实参</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Callback&gt;</span><br><span class="line"><span class="type">void</span> thread_pool&lt;Callback&gt;::<span class="built_in">add_task</span>(task_type&amp;&amp; task) &#123;</span><br><span class="line">    <span class="comment">// 向请求队列中添加任务，需要对请求队列进行锁保护</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">    <span class="comment">// 若请求队列中的任务数超出最大请求数上限，应该延迟添加，而不应该拒绝请求</span></span><br><span class="line">    <span class="comment">// 即阻塞生产者线程，等待工作线程取出任务为请求队列腾出空间以添加新任务</span></span><br><span class="line">    <span class="keyword">while</span> (_task_queue-&gt;<span class="built_in">size</span>() &gt;= _max_requests) &#123;</span><br><span class="line">        <span class="comment">// 若生产者线程此时处于加锁状态，则自动解锁，但不解除阻塞</span></span><br><span class="line">        <span class="comment">// 若生产者线程解除阻塞，则再次加锁，以执行临界区（while循环后面的代码）</span></span><br><span class="line">        _cond_producer.<span class="built_in">wait</span>(lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向请求队列中添加新任务，forward用于保持实参类型信息</span></span><br><span class="line">    _task_queue-&gt;<span class="built_in">emplace</span>(std::forward&lt;task_type&gt;(task));</span><br><span class="line">    <span class="comment">// 解锁并唤醒阻塞在条件变量上的一个工作线程，让其处理任务</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line">    _cond_consumer.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作线程从请求队列中拉取任务进行处理</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Callback&gt;</span><br><span class="line"><span class="type">void</span> thread_pool&lt;Callback&gt;::<span class="built_in">worker</span>() &#123;</span><br><span class="line">    <span class="comment">// 从请求队列中拉取任务，需要对请求队列进行锁保护</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">    <span class="comment">// 先判断线程池状态，若为开启则一直进行事件循环</span></span><br><span class="line">    <span class="keyword">while</span> (_pool_status != _pool_shutdown) &#123;</span><br><span class="line">        <span class="comment">// 队列中有任务，工作线程拉取并处理</span></span><br><span class="line">        <span class="keyword">if</span> (!_task_queue-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            task_type task = _task_queue-&gt;<span class="built_in">front</span>();</span><br><span class="line">            _task_queue-&gt;<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 取出任务就解锁，并唤醒可能阻塞的生产者线程</span></span><br><span class="line">            lock.<span class="built_in">unlock</span>();</span><br><span class="line">            _cond_producer.<span class="built_in">notify_one</span>();</span><br><span class="line">            <span class="comment">// 工作线程执行任务</span></span><br><span class="line">            <span class="built_in">task</span>();</span><br><span class="line">            <span class="comment">// 再次加锁，用于下一次循环中拉取任务时，对请求队列进行锁保护</span></span><br><span class="line">            lock.<span class="built_in">lock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 无任务则工作线程阻塞以待有任务处理</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若工作线程此时处于加锁状态，则自动解锁，但不解除阻塞</span></span><br><span class="line">            <span class="comment">// 若工作线程解除阻塞，则再次加锁，以执行临界区（下一次循环）</span></span><br><span class="line">            _cond_consumer.<span class="built_in">wait</span>(lock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用指令</title>
    <url>/2023/08/07/Tools/Git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="1-git-init"><a href="#1-git-init" class="headerlink" title="1. git init"></a>1. git init</h2><p>在项目的根目录下创建一个<code>.git</code>子目录，用于保存版本信息。</p>
<h2 id="2-git-add"><a href="#2-git-add" class="headerlink" title="2. git add"></a>2. git add</h2><p>将文件保存为二进制对象并更新暂存区，<code>git add --all</code>可保存当前工作目录的所有文件。</p>
<h2 id="3-git-status"><a href="#3-git-status" class="headerlink" title="3. git status"></a>3. git status</h2><p>显示当前仓库状态，即输出哪些文件已修改，哪些文件已暂存等信息。</p>
<h2 id="4-git-commit"><a href="#4-git-commit" class="headerlink" title="4. git commit"></a>4. git commit</h2><p><code>git commit -m &quot;message&quot;</code>将暂存区的文件提交至版本历史记录中，并附带一条描述信息。同时提交目录结构和说明，生成快照（保存当前目录结构，以及每个文件对应的二进制对象）。</p>
<h2 id="5-git-log"><a href="#5-git-log" class="headerlink" title="5. git log"></a>5. git log</h2><p>查看整个版本历史，即当前分支的所有快照。所谓分支就是指向某个快照的指针，分支名即指针名。其中有一个特殊的指针<code>HEAD</code>，总是指向当前分支的最近一次快照。</p>
<div align="center" style=transform:scale(1)>
<img src="/images/git_log.png" />
</div>

<h2 id="6-git-clone"><a href="#6-git-clone" class="headerlink" title="6. git clone"></a>6. git clone</h2><p><code>git clone https://***</code>复制URL所指的远程仓库的所有代码和历史记录，并在本地创建与远程仓库相同的仓库副本。</p>
<h2 id="7-git-branch"><a href="#7-git-branch" class="headerlink" title="7. git branch"></a>7. git branch</h2><p><code>git branch dev</code>创建名为<code>dev</code>的分支，若不带参数，则<code>git branch</code>可以查看当前仓库的所有分支。<br><code>git branch -d dev</code>删除名为dev的分支。</p>
<h2 id="8-git-checkout"><a href="#8-git-checkout" class="headerlink" title="8. git checkout"></a>8. git checkout</h2><p><code>git checkout dev</code>从当前分支切换到名为<code>dev</code>的分支，若携带<code>-b</code>参数（<code>git checkout -b dev</code>）则会先新建一个名为<code>dev</code>的分支并切换到该分支。相当于<code>git branch dev</code> +  <code>git checkout dev</code>。</p>
<h2 id="9-git-merge"><a href="#9-git-merge" class="headerlink" title="9. git merge"></a>9. git merge</h2><p><code>git merge dev</code>合并名为<code>dev</code>的分支到主分支上去，可能会出现合并冲突，需要手动去修改它。</p>
<h2 id="10-git-remote"><a href="#10-git-remote" class="headerlink" title="10. git remote"></a>10. git remote</h2><p><code>git remote -v</code>列出当前仓库中已配置的远程仓库，并显示对应的URL，不加<code>-v</code>，则只列出远程仓库名。</p>
<div align="center" style=transform:scale(1)>
<img src="/images/git_remote.png" />
</div>

<p><code>git remote show origin</code>可显示指定名为<code>origin</code>的远程仓库的详细信息，包括URL和跟踪分支。<br><code>git remote add origin https://***</code>向当前仓库添加一个名为<code>origin</code>的远程仓库，且对应的URL为远程仓库的地址。</p>
<h2 id="11-git-fetch"><a href="#11-git-fetch" class="headerlink" title="11. git fetch"></a>11. git fetch</h2><p><code>git fetch origin</code>从名为<code>origin</code>的远程仓库拉取代码库，获取远程有而本地没有的数据。</p>
<h2 id="12-git-pull"><a href="#12-git-pull" class="headerlink" title="12. git pull"></a>12. git pull</h2><p>用于从远程获取代码并合并本地的版本，相当于<code>git fetch origin</code> + <code>git merge origin/master</code>的简写。<br><code>git pull origin master:dev</code>将远程仓库<code>origin</code>的<code>master</code>分支拉取过来，并与本地的<code>dev</code>分支合并。<br><code>git pull origin master</code>省略冒号时，默认将远程仓库<code>origin</code>的<code>master</code>分支与本地的当前分支合并。</p>
<h2 id="13-git-push"><a href="#13-git-push" class="headerlink" title="13. git push"></a>13. git push</h2><p>使用方式为<code>git push &lt;远程仓库名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code>，如<code>git push origin master:master</code>，将本地<code>master</code>分支推送到<code>origin</code>远程仓库的<code>master</code>分支，也可简写为<code>git push origin master</code>。</p>
<h2 id="14-git-rm"><a href="#14-git-rm" class="headerlink" title="14. git rm"></a>14. git rm</h2><p><code>git rm 1.txt</code>从暂存区和工作区删除<code>1.txt</code>文件。<br><code>git rm -f 1.txt</code>若删除之前修改过且已经存放到暂存区，则必须用<code>-f</code>强制删除。<br><code>git rm --cached 1.txt</code>将文件从暂存区移除，但仍保留在当前工作目录中，仅从跟踪清单中删除。</p>
<h2 id="15-git-reset"><a href="#15-git-reset" class="headerlink" title="15. git reset"></a>15. git reset</h2><p>用于回退版本，可以指定回退到某一次提交的版本。<br><code>git reset HEAD^</code>回退所有内容至上一个版本。<br><code>git reset HEAD^2</code>回退所有内容至上上一个版本。<br><code>git reset HEAD^ 1.txt</code>回退<code>1.txt</code>到上一个版本。<br><code>git reset --hard HEAD</code>使用<code>--hard</code>参数可以撤销工作区中所有未提交的修改内容，将暂存区和工作区都回到上一个版本，并删除之前的所有提交信息。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（下篇）</title>
    <url>/2023/06/07/Fundamentals/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F2/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="Decorator–装饰模式"><a href="#Decorator–装饰模式" class="headerlink" title="Decorator–装饰模式"></a><a href="https://www.bilibili.com/video/BV1Yr4y157Ci/?p=6&spm_id_from=pageDriver&vd_source=65122611208f4d2dd8e86fb48f5e4e28">Decorator–装饰模式</a></h2><ul>
<li><p>概念：动态（组合方式）地给一个对象增加一些额外的功能，比生成子类（继承方式）更加灵活，并能消除代码重复，以及减少子类个数。</p>
</li>
<li><p>实现：设计继承于接口类（抽象基类）的中间类，并且包含一个抽象基类的指针成员，即在接口上表现为<code>is-a</code>，而在实现上表现为<code>has-a</code>。最后通过继承中间类以完成对功能的统一扩展。</p>
</li>
<li><p>场景：设计IO库时，需在基础的流操作上增加一些额外操作（加密、缓冲），若每扩展一次操作都使用一次继承来实现，那么随着组合的增加，子类及其相关代码会变得极其臃肿，且代码中存在大量重复操作。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象基类，提供一些公共接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">char</span> <span class="title">read</span><span class="params">(<span class="type">int</span> num)</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">char</span> data)</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Stream</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件流</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileStream</span> : <span class="keyword">public</span> Stream &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">char</span> <span class="title">read</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">char</span> data)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网络流</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NetworkStream</span> : <span class="keyword">public</span> Stream &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">char</span> <span class="title">read</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">char</span> data)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在对流的加密扩展中，实际上加密操作是一致的，而过度使用继承则导致存在大量重复的加密代码。</span></span><br><span class="line"><span class="comment">// 不仅造成了代码的冗余，而且随着需求的变动，若要修改加密方式，则所有出现加密的地方都要进行更改。</span></span><br><span class="line"><span class="comment">// 扩展操作：对文件流加密</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CryptoFileStream</span> : <span class="keyword">public</span> FileStream &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">char</span> <span class="title">read</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 额外的加密操作...</span></span><br><span class="line">            FileStream::<span class="built_in">read</span>(num); <span class="comment">// 读文件流</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">char</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 额外的加密操作...</span></span><br><span class="line">            FileStream::<span class="built_in">write</span>(data); <span class="comment">// 写文件流</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展操作：对网络流加密</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CryptoNetworkStream</span> : <span class="keyword">public</span> NetworkStream &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">char</span> <span class="title">read</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 额外的加密操作...</span></span><br><span class="line">            NetworkStream::<span class="built_in">read</span>(num); <span class="comment">// 读网络流</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">char</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 额外的加密操作...</span></span><br><span class="line">            NetworkStream::<span class="built_in">write</span>(data); <span class="comment">// 写网络流</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展操作：对文件流缓冲</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferedFileStream</span> : <span class="keyword">public</span> FileStream &#123; ... &#125;;</span><br><span class="line"><span class="comment">// 扩展操作：对网络流缓冲</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferedNetworkStream</span> : <span class="keyword">public</span> NetworkStream &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>重构：定义一个中间类，继承于抽象基类，并声明一个抽象基类的指针（用于多态调用）作为类成员。通过继承中间类来完成操作的扩展，从而将原先的编译时装配转换为运行时装配。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象基类，提供一些公共接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">char</span> <span class="title">read</span><span class="params">(<span class="type">int</span> num)</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">char</span> data)</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Stream</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件流</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileStream</span> : <span class="keyword">public</span> Stream &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">char</span> <span class="title">read</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">char</span> data)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网络流</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NetworkStream</span> : <span class="keyword">public</span> Stream &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">char</span> <span class="title">read</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">char</span> data)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间类，继承Stream，并内含一个Stream的指针成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecoratorStream</span> : <span class="keyword">public</span> Stream &#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        Stream *stream; <span class="comment">// 由运行时完成绑定（文件流或网络流）</span></span><br><span class="line">        <span class="built_in">DecoratorStream</span>(Stream *stm) : <span class="built_in">stream</span>(stm) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展操作：对流加密的统一操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CryptoStream</span> : <span class="keyword">public</span> DecoratorStream &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">CryptoStream</span>(Stream *stm) : <span class="built_in">DecoratorStream</span>(stm) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">char</span> <span class="title">read</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 额外的加密操作...</span></span><br><span class="line">            stream-&gt;<span class="built_in">read</span>(num); <span class="comment">// 读文件流</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">char</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 额外的加密操作...</span></span><br><span class="line">            stream-&gt;<span class="built_in">write</span>(data); <span class="comment">// 写文件流</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展操作：对流缓冲的统一操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferedStream</span> : <span class="keyword">public</span> DecoratorStream &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Factory–工厂模式"><a href="#Factory–工厂模式" class="headerlink" title="Factory–工厂模式"></a><a href="https://www.bilibili.com/video/BV1Yr4y157Ci?p=8&vd_source=65122611208f4d2dd8e86fb48f5e4e28">Factory–工厂模式</a></h2><ul>
<li><p>概念：通过“对象创建”模式绕开<code>new</code>，以避免<code>new</code>过程中所导致的紧耦合（依赖具体类），实现对象创建的稳定。</p>
</li>
<li><p>实现：定义一个用于创建对象的接口，让子类决定实例化哪一个具体类，使得一个类的实例化延迟到子类。缺点在于要求对象创建时的参数相同。</p>
</li>
<li><p>场景：文件分割器对于不同类型的文件采取不同的分割算法，常规思路是定义一个抽象基类（面向接口编程），派生类继承该抽象基类并实现其中用于分割的虚函数。然后在需要进行文件分割时，用抽象基类指针（依赖抽象）指向具体的派生类对象（依赖细节，违反依赖倒置原则）以完成多态调用。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Splitter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">split</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Splitter</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 具体的文件文件分割器，实现不同的分割算法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TxtSplitter</span> : <span class="keyword">public</span> Splitter &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PictureSplitter</span> : <span class="keyword">public</span> Splitter &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoSplitter</span> : <span class="keyword">public</span> Splitter &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainForm</span> : <span class="keyword">public</span> Form &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">buttonClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 面向接口编程，利用抽象基类指针指向派生类对象</span></span><br><span class="line">            <span class="comment">// 此时对于等号左边来说，抽象基类指针已完成依赖抽象</span></span><br><span class="line">            <span class="comment">// 但等号右边是一个具体的派生类，依然是依赖细节，因此违反了依赖倒置原则</span></span><br><span class="line">            Splitter *splitter = <span class="keyword">new</span> <span class="built_in">TxtSplitter</span>();</span><br><span class="line">            splitter-&gt;<span class="built_in">split</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>重构：使用函数返回对象的方式绕开<code>new</code>来创建对象，具体实现是先创建一个工厂的抽象基类，再为每一个具体类都创建一个具体工厂（继承于工厂的抽象基类），并在具体工厂中重写创建函数（工厂的抽象基类中的纯虚函数）以创建对应的具体类（真正使用<code>new</code>的地方）。最后在需要创建对象时，将工厂的抽象基类声明为形参，并传递具体的工厂作为实参。从而实现将常规new操作转换为多态<code>new</code>，使得等号两边都符合依赖抽象。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Splitter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">split</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Splitter</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 具体类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TxtSplitter</span> : <span class="keyword">public</span> Splitter &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PictureSplitter</span> : <span class="keyword">public</span> Splitter &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoSplitter</span> : <span class="keyword">public</span> Splitter &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂的抽象基类，声明一个用于创建对象的接口（纯虚函数）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SplitterFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> Splitter* <span class="title">createSplitter</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">SplitterFactory</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 针对每一个具体类都创建一个具体工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TxtSplitterFactory</span> : <span class="keyword">public</span> SplitterFactory &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> Splitter* <span class="title">createSplitter</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TxtSplitter</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PictureSplitterFactory</span> : <span class="keyword">public</span> SplitterFactory &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> Splitter* <span class="title">createSplitter</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">PictureSplitter</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoSplitterFactory</span> : <span class="keyword">public</span> SplitterFactory &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> Splitter* <span class="title">createSplitter</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">VideoSplitter</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainForm</span> : <span class="keyword">public</span> Form &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        SplitterFactory *factory;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 传递一个具体的工厂作为参数给构造函数，来用于后续创建具体类的流程</span></span><br><span class="line">        <span class="built_in">MainForm</span>(SplitterFactory *factory) : <span class="built_in">factory</span>(factory) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">buttonClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 此时就将常规的new转换成了多态new，从而保证等号两边都依赖抽象</span></span><br><span class="line">            Splitter *splitter = factory-&gt;<span class="built_in">createSplitter</span>();</span><br><span class="line">            splitter-&gt;<span class="built_in">split</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Abstract-Factory–抽象工厂"><a href="#Abstract-Factory–抽象工厂" class="headerlink" title="Abstract Factory–抽象工厂"></a><a href="https://www.bilibili.com/video/BV1Yr4y157Ci/?p=9&spm_id_from=pageDriver&vd_source=65122611208f4d2dd8e86fb48f5e4e28">Abstract Factory–抽象工厂</a></h2><ul>
<li><p>概念：与简单工厂相同，都是绕过常规的对象创建方式（<code>new</code>）来完成对象创建，但主要解决的是“一系列相互依赖的对象”的创建工作，而非单个对象。</p>
</li>
<li><p>实现：提供一个接口，让其负责创建一系列相互依赖的对象，无需指定它们具体的类。</p>
</li>
<li><p>场景：数据访问层需创建一系列的对象，进行数据库连接、执行数据库命令等。若继续使用简单工厂模式，则需要为多个对象创建多个工厂。但这些对象之间都是相互依赖的，换句话说不同系列的对象不能搭配使用（不能用SQL Server的数据库连接去执行MySQL的命令）。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据库访问的接口类（抽象基类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DBConnection</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DBCommand</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// 支持MySQL</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySQLConnection</span> : <span class="keyword">public</span> DBConnection &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySQLCommand</span> : <span class="keyword">public</span> DBCommand &#123;&#125;;</span><br><span class="line"><span class="comment">// 支持SQL Server</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlServerConnection</span> : <span class="keyword">public</span> DBConnection &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlServerCommand</span> : <span class="keyword">public</span> DBCommand &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂的抽象基类，声明用于创建对象的接口（纯虚函数）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DBConnectionFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> DBConnection* <span class="title">createDBConnection</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DBCommandFatory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> DBCommand* <span class="title">createDBCommand</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 支持MySQL的具体工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySQLConnectionFactory</span> : <span class="keyword">public</span> DBConnectionFactory &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> DBConnection* <span class="title">createDBConnection</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySQLCommandFactory</span> : <span class="keyword">public</span> DBCommandFatory &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> DBCommand* <span class="title">createDBCommand</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 支持SQL Server的具体工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SQLServerConnectionFactory</span> : <span class="keyword">public</span> DBConnectionFactory &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> DBConnection* <span class="title">createDBConnection</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SQLServerCommandFactory</span> : <span class="keyword">public</span> DBCommandFatory &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> DBCommand* <span class="title">createDBCommand</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmployeDAO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        DBConnectionFactory* dbConnectionFactory;</span><br><span class="line">        DBCommandFatory* dbCommandFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">vector&lt;EmployeDAO&gt; <span class="title">GetEmployees</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            DBConnection* connection = dbConnectionFactory-&gt;<span class="built_in">createDBConnection</span>();</span><br><span class="line">            DBCommand* command = dbCommandFactory-&gt;<span class="built_in">createDBCommand</span>();</span><br><span class="line">            <span class="comment">// 此处表明具体的命令需要与对应的具体连接相关（二者相互依赖），不同系列的对象不能搭配使用</span></span><br><span class="line">            command-&gt;<span class="built_in">setConnection</span>(connection);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>重构：将同一系列的对象创建工作都交由一个工厂完成，而非多个工厂。不仅可以简化代码结构，使代码更加清晰优雅，还可以避免错误地搭配不同系列对象的情况。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> DBConnection* <span class="title">createDBConnection</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> DBCommand* <span class="title">createDBCommand</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySQLFactory</span> : <span class="keyword">public</span> DBFactory &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> DBConnection* <span class="title">createDBConnection</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> DBCommand* <span class="title">createDBCommand</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmployeDAO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        DBFactory* dbFactory;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">vector&lt;EmployeDAO&gt; <span class="title">GetEmployees</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            DBConnection* connection = dbFactory-&gt;<span class="built_in">createDBConnection</span>();</span><br><span class="line">            DBCommand* command = dbFactory-&gt;<span class="built_in">createDBCommand</span>();</span><br><span class="line">            <span class="comment">// 此时同一系列对象之间的关联性得到了保证</span></span><br><span class="line">            command-&gt;<span class="built_in">setConnection</span>(connection);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Proxy–代理模式"><a href="#Proxy–代理模式" class="headerlink" title="Proxy–代理模式"></a><a href="https://www.bilibili.com/video/BV1Yr4y157Ci?p=15&vd_source=65122611208f4d2dd8e86fb48f5e4e28">Proxy–代理模式</a></h2><ul>
<li>概念：在面向对象系统中，有些对象由于某种原因（如对象创建开销大、某些操作需要安全控制、或需要进程外的访问–分布式系统等）直接访问会给系统结构造成麻烦。因此需要增加一层间接层，以确保在不失去接口一致性的同时来控制对象特有的复杂性。</li>
</ul>
<div align="center" style=transform:scale(0.9)>
<img src="/images/代理模式.png"/>
</div>

<ul>
<li><p>实现：为其他对象提供一种代理以控制（隔离，使用接口）对这个对象的访问。</p>
</li>
<li><p>场景：直接访问式</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject</span>: <span class="keyword">public</span> Subject &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123; <span class="comment">// ... &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Subject *subject;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 这种方式可能因为上述内容中的某种原因，导致压根拿不到RealSubject</span></span><br><span class="line">        <span class="built_in">Client</span>() &#123; subject = <span class="keyword">new</span> <span class="built_in">RealSubject</span>(); <span class="comment">// ... &#125;</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">doTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// ...  </span></span><br><span class="line">            subject-&gt;<span class="built_in">process</span>();</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>重构：使用代理模式（分布式中大量应用），在某些平台常常使用工具生成</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Proxy和RealSubject通常是保证接口一致性，从而使客户端感觉是一致的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span> : <span class="keyword">public</span> Subject &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 对RealSubject的一种间接访问</span></span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Subject *subject;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Client</span>() &#123; subject = <span class="keyword">new</span> <span class="built_in">Proxy</span>(); &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">doTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// ...  </span></span><br><span class="line">            subject-&gt;<span class="built_in">process</span>();</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Adapter–适配器模式"><a href="#Adapter–适配器模式" class="headerlink" title="Adapter–适配器模式"></a><a href="https://www.bilibili.com/video/BV1Yr4y157Ci?p=16&vd_source=65122611208f4d2dd8e86fb48f5e4e28">Adapter–适配器模式</a></h2><ul>
<li><p>概念：将一个类的接口转换成客户希望的另一个接口，使原本由于接口不兼容而无法工作的那些类可以一起工作。</p>
</li>
<li><p>场景：<code>STL</code>中的有三种类型的适配器</p>
<ul>
<li>容器适配器：<code>stack</code>、<code>queue</code>、<code>priority_queue</code></li>
<li>迭代器适配器：插入迭代器、反向迭代器、流迭代器</li>
<li>仿函数适配器：绑定（<code>bind</code>）、否定（<code>negate</code>）、组合（<code>compose</code>）</li>
</ul>
</li>
</ul>
<h2 id="Iterator–迭代器模式"><a href="#Iterator–迭代器模式" class="headerlink" title="Iterator–迭代器模式"></a><a href="https://www.bilibili.com/video/BV1Yr4y157Ci/?p=21&spm_id_from=pageDriver&vd_source=65122611208f4d2dd8e86fb48f5e4e28">Iterator–迭代器模式</a></h2><ul>
<li><p>概念：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露（稳定）该对象的内部表示。</p>
</li>
<li><p>场景：<code>STL</code>中各种容器都提供自己专有的迭代器，需注意GOF中迭代器模是以面向对象方式中的虚函数实现运行时多态，但迭代器一般用于循环中，因此在循环次数较多时，虚函数的频繁调用（需通过虚函数表指针寻找函数地址–二次的指针间接运算）会导致极高的成本。因此<code>STL</code>中的迭代器采用模板技术实现编译时多态，以提高性能。</p>
</li>
<li><p><code>STL</code>迭代器类型（5种）</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入迭代器：只读，不允许外界改变，例如输入流迭代器。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator_tag</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// 输出迭代器：唯写，例如输出流迭代器，只重载赋值运算符</span></span><br><span class="line"><span class="comment">// 其余运算符（递增、解引用），只返回*this自身，不起作用，从而实现关闭功能。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iterator_tag</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// 前向迭代器：允许“写入型”算法在此迭代器所形成的区间上进行读写操作</span></span><br><span class="line"><span class="comment">// 例如forward_list、以哈希表实现的unordered系列set和map（vector实现的桶中的链表为单向链表）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator_tag</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// 双向迭代器：可双向移动，某些算法（copy_backward）需要逆向访问区间</span></span><br><span class="line"><span class="comment">// 例如list、以红黑树实现的set和map</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bidirectional_iterator_tag</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// 随机访问迭代器：涵盖指针所有的算术能力（加法、减法、下标运算、比较、解引用），例如vector、deque</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator_tag</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>STL</code>迭代器特性（5种）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Category</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span> = <span class="type">ptrdiff_t</span>,</span><br><span class="line">         <span class="keyword">class</span> Pointer = T*, <span class="keyword">class</span> Reference = T&amp;&gt;</span><br><span class="line"><span class="keyword">struct</span> iterator &#123;</span><br><span class="line">    <span class="keyword">typedef</span> Category  iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T         value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Distance  difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> Pointer   pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Reference reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于进行迭代器特性萃取的traits技巧</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::iterator_category iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type        value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::difference_type   difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::pointer           pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::reference         reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>基于跳表实现的有序关联容器</title>
    <url>/2023/07/21/Project/SkipList/</url>
    <content><![CDATA[<span id="more"></span>

<p>本项目地址：<a href="https://github.com/lijiang99/SkipList/tree/main">https://github.com/lijiang99/SkipList/tree/main</a></p>
<p>参考资料：<a href="https://github.com/tolerious/Programming_learning_resource/blob/master/C%2B%2B/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%88%E6%89%B9%E6%B3%A8%E7%89%88%EF%BC%89.pdf">《STL源码剖析》</a>、<a href="https://github.com/youngyangyang04/Skiplist-CPP">基于跳表实现的轻量级键值数据库</a></p>
<h2 id="skiplist概述"><a href="#skiplist概述" class="headerlink" title="skiplist概述"></a>skiplist概述</h2><div align="center" style=transform:scale(0.9)>
<img src="/images/跳表结构0.png"/>
</div>

<p>跳表是一种以空间换时间的方式实现具备二分查找能力的有序链表，其特点有：</p>
<ul>
<li>为每个节点增加多级索引，通过索引实现快速增删改查，将时间复杂度由$O(N)$降至$O(logN)$。</li>
<li>每个节点能够索引的层数是随机的，在生成节点的过程中由抛硬币决定（每次迭代以$50\%$的概率增长）。</li>
</ul>
<h2 id="skiplist的节点"><a href="#skiplist的节点" class="headerlink" title="skiplist的节点"></a>skiplist的节点</h2><p>有别于传统链表的节点，跳表节点中除了所保存的元素值，还有一个<code>forward</code>数组，其大小由节点的层级<code>level</code>（随机生成）决定，为<code>level+1</code>，而<code>forward[i]</code>则记录当前节点在第i层的后继节点的位置。第$0$层的所有节点都是依序相连的，本质上就是有序链表，因此想要获取跳表所有节点的元素值，依次寻访第$0$层的所有节点即可，而其他层则是跳跃相连，只保证后继节点的元素值大于当前节点。以下是跳表节点的结构：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__skiplist_node</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> __skiplist_node&lt;Value&gt;* link_type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 节点值</span></span><br><span class="line">	Value value_field;</span><br><span class="line">	<span class="comment">// 节点层级</span></span><br><span class="line">	<span class="type">size_t</span> level;</span><br><span class="line">	<span class="comment">// forward是大小为level+1的数组，元素为指针，指向当前节点在每层的后继节点</span></span><br><span class="line">	link_type *forward;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造函数</span></span><br><span class="line">	__skiplist_node(Value value_field, <span class="type">size_t</span> level)</span><br><span class="line">        : <span class="built_in">value_field</span>(value_field), <span class="built_in">level</span>(level) &#123;</span><br><span class="line">		<span class="comment">// forward的大小为level+1，因为层数从0开始</span></span><br><span class="line">		forward = <span class="keyword">new</span> link_type[level+<span class="number">1</span>];</span><br><span class="line">		<span class="comment">// 初始化分配的内存空间，将内存清零</span></span><br><span class="line">		<span class="built_in">bzero</span>(forward, <span class="built_in">sizeof</span>(link_type)*(level+<span class="number">1</span>));</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">// 析构函数，释放forward指向的动态分配的内存</span></span><br><span class="line">	~__skiplist_node() &#123; <span class="keyword">delete</span> [] forward; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="skiplist的迭代器"><a href="#skiplist的迭代器" class="headerlink" title="skiplist的迭代器"></a>skiplist的迭代器</h2><p>从跳表的节点定义不难看出，跳表在第$0$层实质上是一个单向链表，因此迭代器只具备前移，而不具备后移的能力，所以跳表提供的是<code>Forward Iterator</code>，且跳表的插入操作不会造成原有迭代器失效。而对删除来说，只有指向被删除元素的那个迭代器会失效，其他迭代器不受影响。此外迭代器还应该具备解引用、成员访问、相等性判断的能力，以下是跳表迭代器的设计：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value, <span class="keyword">typename</span> Ref, <span class="keyword">typename</span> Ptr&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__skiplist_iterator</span> &#123;</span><br><span class="line">    <span class="comment">// 定义迭代器的五种特性，使其适配iterator_traits进行特性提取，并兼容STL算法</span></span><br><span class="line">    <span class="keyword">typedef</span> Value value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">    <span class="comment">// 迭代器类型为前向迭代器</span></span><br><span class="line">    <span class="keyword">typedef</span> std::forward_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> __skiplist_iterator&lt;Value, Value&amp;, Value*&gt; iterator;</span><br><span class="line">    <span class="keyword">typedef</span> __skiplist_iterator&lt;Value, <span class="type">const</span> Value&amp;, <span class="type">const</span> Value*&gt; const_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> __skiplist_iterator&lt;Value, Ref, Ptr&gt; self;</span><br><span class="line">    <span class="keyword">typedef</span> __skiplist_node&lt;Value&gt;* link_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器的唯一数据就是一个原生指针</span></span><br><span class="line">    link_type node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    __skiplist_iterator(link_type x = <span class="literal">nullptr</span>) : <span class="built_in">node</span>(x) &#123;&#125;</span><br><span class="line">    __skiplist_iterator(<span class="type">const</span> iterator &amp;it) : <span class="built_in">node</span>(it.node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载解引用运算</span></span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> node-&gt;value_field; &#125;</span><br><span class="line">    <span class="comment">// 重载成员访问运算符的标准操作</span></span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载递增运算符，因为是单向迭代器类型，所以不支持递减运算</span></span><br><span class="line">    self&amp; <span class="keyword">operator</span>++() &#123; node = node-&gt;forward[<span class="number">0</span>]; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125; <span class="comment">// 前置递增</span></span><br><span class="line">    self&amp; <span class="keyword">operator</span>++(<span class="type">int</span>) &#123; self tmp = *<span class="keyword">this</span>; node = node-&gt;forward[<span class="number">0</span>]; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125; <span class="comment">// 后置递增</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载==和!=运算符，用于条件判断</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> iterator &amp;it) <span class="type">const</span> &#123; <span class="keyword">return</span> node == it.node; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> iterator &amp;it) <span class="type">const</span> &#123; <span class="keyword">return</span> node != it.node; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> const_iterator &amp;it) <span class="type">const</span> &#123; <span class="keyword">return</span> node == it.node; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> const_iterator &amp;it) <span class="type">const</span> &#123; <span class="keyword">return</span> node != it.node; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="skiplist的数据结构"><a href="#skiplist的数据结构" class="headerlink" title="skiplist的数据结构"></a>skiplist的数据结构</h2><p>下面是跳表的定义，可以看到其中定义有专属的跳表迭代器，各种类型的别名定义，以及用来维护整个跳表的五笔数据（其中的仿函数用于规定节点的大小比较方式）。虽然每个节点的层数是随机的，但也不能无限制增长，因此需要一个层级上限加以限定，而且该上限即为头节点的层数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> KeyOfValue, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">skiplist</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 定义跳表的基础类型</span></span><br><span class="line">        <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">        <span class="keyword">typedef</span> Value value_type;</span><br><span class="line">        <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">const</span> value_type* const_pointer;</span><br><span class="line">        <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">const</span> value_type&amp; const_reference;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义跳表的专属迭代器</span></span><br><span class="line">        <span class="keyword">typedef</span> __skiplist_iterator&lt;value_type, reference, pointer&gt; iterator;</span><br><span class="line">        <span class="keyword">typedef</span> __skiplist_iterator&lt;value_type, const_reference, const_pointer&gt; const_iterator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">typedef</span> __skiplist_node&lt;Value&gt; skiplist_node;</span><br><span class="line">        <span class="keyword">typedef</span> skiplist_node* link_type;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 整个跳表通过以下五笔数据维护</span></span><br><span class="line">        size_type max_level; <span class="comment">// 层级上限</span></span><br><span class="line">        size_type top_level; <span class="comment">// 当前最高层</span></span><br><span class="line">        size_type node_count; <span class="comment">// 跳表的大小，即节点数量</span></span><br><span class="line">        Compare key_compare; <span class="comment">// 作为节点间键值大小比较准则的函数对象</span></span><br><span class="line">        link_type header; <span class="comment">// 头节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// 生成随机数作为节点层级</span></span><br><span class="line">        <span class="function">size_type <span class="title">random_level</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 创建/销毁/初始化一个节点</span></span><br><span class="line">        <span class="function">link_type <span class="title">create_node</span><span class="params">(<span class="type">const</span> value_type &amp;val, <span class="type">size_t</span> level)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">skiplist_node</span>(val, level); &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">destroy_node</span><span class="params">(link_type node)</span> </span>&#123; <span class="keyword">delete</span> node; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; header = <span class="built_in">create_node</span>(<span class="built_in">value_type</span>(), max_level); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于获得节点的value和key</span></span><br><span class="line">        <span class="function"><span class="type">static</span> reference <span class="title">value</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> x-&gt;value_field; &#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">const</span> Key&amp; <span class="title">key</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">KeyOfValue</span>()(<span class="built_in">value</span>(x)); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于插入和删除节点的核心函数</span></span><br><span class="line">        iterator __insert(link_type *update, <span class="type">const</span> value_type &amp;val);</span><br><span class="line">        <span class="type">void</span> __erase(<span class="type">const</span> key_type &amp;k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="built_in">skiplist</span>(size_type max_level, <span class="type">const</span> Compare &amp;comp = <span class="built_in">Compare</span>())</span><br><span class="line">            : <span class="built_in">max_level</span>(max_level), <span class="built_in">top_level</span>(<span class="number">0</span>), <span class="built_in">node_count</span>(<span class="number">0</span>), <span class="built_in">key_compare</span>(comp) &#123; <span class="built_in">init</span>(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拷贝构造，需复制对象的底层资源，先利用委托构造函数初始化一个空跳表</span></span><br><span class="line">        <span class="comment">// 再复制所有节点值（value_field），不复制节点结构（level和forward）</span></span><br><span class="line">        <span class="built_in">skiplist</span>(<span class="type">const</span> skiplist&lt;Key, Value, KeyOfValue, Compare&gt; &amp;rhs)</span><br><span class="line">            : <span class="built_in">skiplist</span>(rhs.max_level, rhs.key_compare) &#123; <span class="built_in">insert_unique</span>(rhs.<span class="built_in">begin</span>(), rhs.<span class="built_in">end</span>()); &#125;</span><br><span class="line">        <span class="comment">// 拷贝赋值，利用按值传递来自动处理自赋值的情况，并确保异常安全</span></span><br><span class="line">        <span class="comment">// 但按值传递会调用拷贝构造，所以自赋值时会改变节点结构（level和forward）</span></span><br><span class="line">        skiplist&lt;Key, Value, KeyOfValue, Compare&gt;&amp; <span class="keyword">operator</span>=(skiplist&lt;Key, Value, KeyOfValue, Compare&gt; rhs) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(rhs);</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 交换操作</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(skiplist&lt;Key, Value, KeyOfValue, Compare&gt; &amp;rhs)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构函数，需要先清空跳表，再释放头节点</span></span><br><span class="line">        ~<span class="built_in">skiplist</span>() &#123; <span class="built_in">clear</span>(); <span class="built_in">destroy_node</span>(header); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取作为节点间键值大小比较准则的函数对象</span></span><br><span class="line">        <span class="function">Compare <span class="title">key_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> key_compare; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首尾迭代器，首迭代器即头节点在第0层的后继，因为是单向链表，所以无反向迭代器</span></span><br><span class="line">        <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> header-&gt;forward[<span class="number">0</span>]; &#125;</span><br><span class="line">        <span class="function">const_iterator <span class="title">cbegin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> header-&gt;forward[<span class="number">0</span>]; &#125;</span><br><span class="line">        <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125;</span><br><span class="line">        <span class="function">const_iterator <span class="title">cend</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义数据规模的相关函数</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> node_count == <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> node_count; &#125;</span><br><span class="line">        <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="number">-1</span>); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将节点插入跳表中，并保证节点唯一</span></span><br><span class="line">        <span class="function">std::pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert_unique</span><span class="params">(<span class="type">const</span> value_type &amp;val)</span></span>;</span><br><span class="line">        <span class="comment">// 将一对迭代器[first, last)表示的范围内的数据插入跳表中</span></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator&gt;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insert_unique</span><span class="params">(InputIterator first, InputIterator last)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据key在跳表中查找节点</span></span><br><span class="line">        <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type &amp;k)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据key在跳表中删除节点</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type &amp;k)</span> </span>&#123; __erase(k); &#125;</span><br><span class="line">        <span class="comment">// 将一对迭代器[first, last)表示的范围内的节点从跳表中删除</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(const_iterator first, const_iterator last)</span></span>;</span><br><span class="line">        <span class="comment">// 清空跳表</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载关系运算符的友元声明</span></span><br><span class="line">        <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==&lt;Key, Value, KeyOfValue, Compare&gt;(<span class="type">const</span> skiplist&lt;Key, Value, KeyOfValue, Compare&gt; &amp;lhs,</span><br><span class="line">                <span class="type">const</span> skiplist&lt;Key, Value, KeyOfValue, Compare&gt; &amp;rhs);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="skiplist的构造和内存管理"><a href="#skiplist的构造和内存管理" class="headerlink" title="skiplist的构造和内存管理"></a>skiplist的构造和内存管理</h2><p>先前所列的程序片段中显示了几个节点相关函数，如<code>random_level</code>、<code>create_node</code>、<code>destroy_node</code>、<code>init</code>，分别用于为节点生成随机层数、创建节点、销毁节点、初始化头节点。而跳表的构造方式有两种，一种生成一个空表，另一种是以现有的跳表复制一个新的跳表，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">skiplist&lt;<span class="type">int</span>, <span class="type">int</span>, identity&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">slst</span>(<span class="number">18</span>);</span><br></pre></td></tr></table></figure>

<p>这段程序代码分别指定列节点键值、实值、键值映射标准、大小比较标准并指定最大层级为$18$，然后调用<code>skiplist</code>的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">skiplist</span>(size_type max_level, <span class="type">const</span> Compare &amp;comp = <span class="built_in">Compare</span>())</span><br><span class="line">    : <span class="built_in">max_level</span>(max_level), <span class="built_in">top_level</span>(<span class="number">0</span>), <span class="built_in">node_count</span>(<span class="number">0</span>), <span class="built_in">key_compare</span>(comp) &#123; <span class="built_in">init</span>(); &#125;</span><br></pre></td></tr></table></figure>

<p>而对于通过以现有跳表复制一个新跳表，则会调用拷贝构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">skiplist&lt;<span class="type">int</span>, <span class="type">int</span>, identity&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">slst_copy</span>(slst);</span><br></pre></td></tr></table></figure>

<p>需注意当比较两个跳表相等性的时候，只需要比较跳表第$0$层所有节点的元素值是否相等即可，而无需比较每个节点的<code>forward</code>数组中的连接关系是否一一对应，因为比较连接关系不仅耗时且无任何实际意义。如下图所示，两个跳表虽然结构不同，但元素值相同，因此两者相等性判断结果应该为<code>true</code>。</p>
<div align="center" style=transform:scale(0.9)>
<img src="/images/跳表结构1.png"/>
</div>
<div align="center" style=transform:scale(0.9)>
<img src="/images/跳表结构2.png"/>
</div>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只判断节点值（value_field）是否相等即可，不需要判断节点结构（level和forward）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> KeyOfValue, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> skiplist&lt;Key, Value, KeyOfValue, Compare&gt; &amp;lhs,</span><br><span class="line">		<span class="type">const</span> skiplist&lt;Key, Value, KeyOfValue, Compare&gt; &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">typename</span> skiplist&lt;Key, Value, KeyOfValue, Compare&gt;::link_type lhs_current = lhs.header-&gt;forward[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">typename</span> skiplist&lt;Key, Value, KeyOfValue, Compare&gt;::link_type rhs_current = rhs.header-&gt;forward[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span> (lhs_current &amp;&amp; rhs_current) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(lhs.<span class="built_in">value</span>(lhs_current) == rhs.<span class="built_in">value</span>(rhs_current))) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        lhs_current = lhs_current-&gt;forward[<span class="number">0</span>];</span><br><span class="line">        rhs_current = rhs_current-&gt;forward[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lhs_current || rhs_current) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出于这一原因，拷贝构造函数也只需保证节点元素值一致，而无需保证节点结构一致。换句话说就是两个跳表第$0$层的连接关系是一一对应的，而其他层级的连接关系并不一致，因为内部调用<code>insert_unique</code>时会为节点生成完全随机的层级。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">skiplist</span>(<span class="type">const</span> skiplist&lt;Key, Value, KeyOfValue, Compare&gt; &amp;rhs)</span><br><span class="line">    : <span class="built_in">skiplist</span>(rhs.max_level, rhs.key_compare) &#123; <span class="built_in">insert_unique</span>(rhs.<span class="built_in">begin</span>(), rhs.<span class="built_in">end</span>()); &#125;</span><br></pre></td></tr></table></figure>

<p>而对于另一个拷贝操作（拷贝赋值运算符），会利用按值传递来自动处理自赋值的情况，并确保异常安全。但按值传递会调用拷贝构造函数，且拷贝赋值运算符内部调用的<code>swap</code>函数通过交换两个跳表的头节点来实现底层资源的交换，所以即便是自赋值，也会改变节点结构（<code>level</code>和<code>forward</code>）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拷贝赋值运算符，类内定义，默认为inline函数</span></span><br><span class="line">skiplist&lt;Key, Value, KeyOfValue, Compare&gt;&amp; <span class="keyword">operator</span>=(skiplist&lt;Key, Value, KeyOfValue, Compare&gt; rhs) &#123;</span><br><span class="line">    <span class="built_in">swap</span>(rhs); <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换操作，类外定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> KeyOfValue, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="type">void</span> skiplist&lt;Key, Value, KeyOfValue, Compare&gt;::<span class="built_in">swap</span>(skiplist&lt;Key, Value, KeyOfValue, Compare&gt; &amp;rhs) &#123;</span><br><span class="line">    std::<span class="built_in">swap</span>(max_level, rhs.max_level);</span><br><span class="line">    std::<span class="built_in">swap</span>(top_level, rhs.top_level);</span><br><span class="line">    std::<span class="built_in">swap</span>(node_count, rhs.node_count);</span><br><span class="line">    <span class="comment">// 交换header即可实现底层资源的置换</span></span><br><span class="line">    std::<span class="built_in">swap</span>(header, rhs.header);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="skiplist的元素操作"><a href="#skiplist的元素操作" class="headerlink" title="skiplist的元素操作"></a>skiplist的元素操作</h2><ul>
<li>元素插入：本项目提供一种形式的插入操作<code>insert_unique</code>，即被插入节点的键值在跳表中必须独一无二，如果跳表中已存在相同的键值，插入操作就不会真正进行。该函数有两个重载版本，其一是插入指定的元素值，且该元素值必须能通过<code>KeyOfValue</code>来提取键值，另一个版本是允许插入一对迭代器所指示范围内的元素值，但真正执行插入操作的为<code>__insert</code>私有成员函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将节点值插入跳表中，并保证节点的键值唯一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> KeyOfValue, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line">std::pair&lt;<span class="keyword">typename</span> skiplist&lt;Key, Value, KeyOfValue, Compare&gt;::iterator, <span class="type">bool</span>&gt;</span><br><span class="line">skiplist&lt;Key, Value, KeyOfValue, Compare&gt;::<span class="built_in">insert_unique</span>(<span class="type">const</span> value_type &amp;val) &#123;</span><br><span class="line">    link_type current = header;</span><br><span class="line">    <span class="comment">// 使用update来保存每层中最后一个满足其key小于待插入节点的key的节点（即前驱节点)</span></span><br><span class="line">    <span class="comment">// update大小设置为max_level+1以确保有足够的空间来存放每层满足条件的节点</span></span><br><span class="line">    link_type update[max_level+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">bzero</span>(update, <span class="built_in">sizeof</span>(link_type)*(max_level+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从跳表最高层开始查找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = top_level; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// 若当前节点的后继不为空且后继的key小于待插入的节点的key</span></span><br><span class="line">        <span class="comment">// 表明需要在当前层继续前进，继续while循环</span></span><br><span class="line">        <span class="keyword">while</span> (current-&gt;forward[i] &amp;&amp; <span class="built_in">key_compare</span>(<span class="built_in">key</span>(current-&gt;forward[i]), <span class="built_in">KeyOfValue</span>()(val)))</span><br><span class="line">            current = current-&gt;forward[i];</span><br><span class="line">        <span class="comment">// 若当前节点的后继为空或后继节点的key大于等于目标节点的key</span></span><br><span class="line">        <span class="comment">// 则current此时即为待插入节点的前一个位置（前驱节点），将其保存到update中</span></span><br><span class="line">        update[i] = current;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当for循环结束时，表明已经查到了第0层</span></span><br><span class="line">    <span class="comment">// 那么current-&gt;forward[0]的key此时可能等于或大于待插入节点的key</span></span><br><span class="line">    current = current-&gt;forward[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若待插入的key已经存在于跳表中，则不插入新值</span></span><br><span class="line">    <span class="keyword">if</span> (current &amp;&amp; !<span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(val), <span class="built_in">key</span>(current)))</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(current, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(__insert(update, val), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一对迭代器[first, last)表示的范围内的数据插入跳表中</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> KeyOfValue, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator&gt;</span><br><span class="line"><span class="type">void</span> skiplist&lt;Key, Value, KeyOfValue, Compare&gt;::<span class="built_in">insert_unique</span>(InputIterator first, InputIterator last) &#123;</span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123; <span class="built_in">insert_unique</span>(*first); ++first; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个节点并设置相应的值以及前驱和后继，返回指向新节点的迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> KeyOfValue, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="keyword">typename</span> skiplist&lt;Key, Value, KeyOfValue, Compare&gt;::iterator</span><br><span class="line">skiplist&lt;Key, Value, KeyOfValue, Compare&gt;::__insert(link_type* update, <span class="type">const</span> value_type &amp;val) &#123;</span><br><span class="line">    <span class="comment">// 为待插入的节点生成随机层数，层索引从0开始，所以实际层数为level+1</span></span><br><span class="line">    size_type level = <span class="built_in">random_level</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若待插入节点的level大于当前跳表中的最高层级top_level（不是max_level）</span></span><br><span class="line">    <span class="comment">// 则表明在层级为[top_level+1, level]范围内，待插入节点的前驱必为header</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; top_level) &#123;</span><br><span class="line">        <span class="keyword">for</span> (size_type i = top_level+<span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">            update[i] = header;</span><br><span class="line">        <span class="comment">// 更新跳表的最高层级</span></span><br><span class="line">        top_level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建待插入的新节点</span></span><br><span class="line">    link_type node = <span class="built_in">create_node</span>(val, level);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新节点在跳表中的前驱和后继</span></span><br><span class="line">    <span class="keyword">for</span> (size_type i = <span class="number">0</span>; i &lt;= level; ++i) &#123;</span><br><span class="line">        <span class="comment">// 将新节点的后继设置为事先所保存的前驱节点的后继</span></span><br><span class="line">        node-&gt;forward[i] = update[i]-&gt;forward[i];</span><br><span class="line">        <span class="comment">// 更新事先所保存的前驱节点的后继为当前节点</span></span><br><span class="line">        update[i]-&gt;forward[i] = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新跳表中的节点总数</span></span><br><span class="line">    ++node_count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回新节点的位置</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>元素删除：有两个重载的版本，可以根据指定的键值，从跳表中删除元素，也可以删除一对迭代器范围内的所有元素，但真正执行删除操作的是<code>__erase</code>私有成员函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据key在跳表中删除节点，类内定义，默认为inline</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type &amp;k)</span> </span>&#123; __erase(k); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一对迭代器[first, last)表示的范围内的节点从跳表中删除</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> KeyOfValue, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="type">void</span> skiplist&lt;Key, Value, KeyOfValue, Compare&gt;::<span class="built_in">erase</span>(const_iterator first, const_iterator last) &#123;</span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        key_type tmp = <span class="built_in">KeyOfValue</span>()(*first);</span><br><span class="line">        ++first;</span><br><span class="line">        __erase(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在跳表中根据key删除节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> KeyOfValue, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="type">void</span> skiplist&lt;Key, Value, KeyOfValue, Compare&gt;::__erase(<span class="type">const</span> key_type &amp;k) &#123;</span><br><span class="line">    link_type current = header;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用update来保存每层中最后一个满足其key小于待删除节点的key的节点（即前驱节点）</span></span><br><span class="line">    <span class="comment">// update大小设置为max_level+1以确保有足够的空间来存放每层满足条件的节点</span></span><br><span class="line">    link_type update[max_level+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">bzero</span>(update, <span class="built_in">sizeof</span>(link_type)*(max_level+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从跳表最高层开始查找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = top_level; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// 若当前节点的后继不为空且后继的key小于目标key</span></span><br><span class="line">        <span class="comment">// 表明需要在当前层继续前进，即继续while循环</span></span><br><span class="line">        <span class="keyword">while</span> (current-&gt;forward[i] &amp;&amp; <span class="built_in">key_compare</span>(<span class="built_in">key</span>(current-&gt;forward[i]), k))</span><br><span class="line">            current = current-&gt;forward[i];</span><br><span class="line">        <span class="comment">// 若当前节点的后继为空或后继节点的key大于等于目标节点的key</span></span><br><span class="line">        <span class="comment">// 则current此时即为待删除节点的前一个位置（前驱节点），将其保存到update中</span></span><br><span class="line">        update[i] = current;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当for循环结束时，表明已经查到了第0层</span></span><br><span class="line">    <span class="comment">// 那么current-&gt;forward[0]的key此时可能等于或大于待删除节点的key</span></span><br><span class="line">    current = current-&gt;forward[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若待删除的key对应的节点在跳表中，则修改前驱和后继</span></span><br><span class="line">    <span class="keyword">if</span> (current &amp;&amp; !<span class="built_in">key_compare</span>(k, <span class="built_in">key</span>(current))) &#123;</span><br><span class="line">        <span class="comment">// 从第0层开始修改</span></span><br><span class="line">        <span class="keyword">for</span> (size_type i = <span class="number">0</span>; i &lt;= top_level; ++i) &#123;</span><br><span class="line">            <span class="comment">// 若前驱的后继不再是待删除的节点，则退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (update[i]-&gt;forward[i] != current) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 将前驱的后继修改为待删除节点的后继</span></span><br><span class="line">            update[i]-&gt;forward[i] = current-&gt;forward[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放节点所占用的内存空间</span></span><br><span class="line">        <span class="built_in">destroy_node</span>(current);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于删除的节点的层级可能为当前跳表的唯一最大层</span></span><br><span class="line">        <span class="comment">// 因此删除节点后，需要更新当前跳表的最大层级</span></span><br><span class="line">        <span class="comment">// 若头节点在最高层的后继为空，则表明最高层为空，需要降低最高层</span></span><br><span class="line">        <span class="keyword">while</span> (top_level &gt; <span class="number">0</span> &amp;&amp; !header-&gt;forward[top_level]) --top_level;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新跳表中的节点总数</span></span><br><span class="line">        --node_count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>元素查找：跳表的设计目标就是根据指定的键值来快速检索元素，并借助节点的多层索引特性来确保时间复杂度为$O(\log{N})$。以下是跳表<code>find</code>函数的定义：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在跳表中根据key查找节点，key存在则返回指向该节点的迭代器，否则返回尾迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> KeyOfValue, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="keyword">typename</span> skiplist&lt;Key, Value, KeyOfValue, Compare&gt;::iterator</span><br><span class="line">skiplist&lt;Key, Value, KeyOfValue, Compare&gt;::<span class="built_in">find</span>(<span class="type">const</span> key_type &amp;k) <span class="type">const</span> &#123;</span><br><span class="line">    link_type current = header;</span><br><span class="line">    <span class="comment">// 从跳表最高层开始查找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = top_level; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// 若当前节点的后继不为空且后继的key小于目标key</span></span><br><span class="line">        <span class="comment">// 表明需要在当前层继续前进，继续while循环</span></span><br><span class="line">        <span class="keyword">while</span> (current-&gt;forward[i] &amp;&amp; <span class="built_in">key_compare</span>(<span class="built_in">key</span>(current-&gt;forward[i]), k))</span><br><span class="line">            current = current-&gt;forward[i];</span><br><span class="line">        <span class="comment">// 若当前节点的后继为空或后继节点的key大于等于目标的key</span></span><br><span class="line">        <span class="comment">// 表明需要向下降一层级，即结束while循环，开启下一次for循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当for循环结束时，表明已经查找到了第0层级</span></span><br><span class="line">    <span class="comment">// 且此时的current节点必定是跳表中满足key小于目标key的所有节点中，key最大的那个节点</span></span><br><span class="line">    <span class="comment">// 若key存在，则current的后继即为所要查找的目标节点</span></span><br><span class="line">    current = current-&gt;forward[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若目标节点在跳表中，则直接返回其位置即可</span></span><br><span class="line">    <span class="keyword">if</span> (current &amp;&amp; !<span class="built_in">key_compare</span>(k, <span class="built_in">key</span>(current))) <span class="keyword">return</span> current;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若目标节点不在跳表中，则返回尾迭代器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>元素清空：可以借助首尾迭代器<code>begin</code>和<code>end</code>以及<code>erase</code>函数实现，虽然这样做可以简化编程（仅需一行代码即可），但是<code>erase</code>函数内部调用的<code>__erase</code>在每次删除一个节点时，都会重新设置被删除节点前驱和后继的连接。这对于清空操作来说完全是多余的步骤，因此在<code>clear</code>函数内部，只需通过头节点依次寻访节点的第$0$层来完成删除操作，且每删除一个节点无需重置前后连接关系，在删除除头节点外的所有节点后重置头节点的<code>forward</code>数组、最高层级、节点数量即可实现跳表的清空。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清空跳表，释放跳表中除header外的所有节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> KeyOfValue, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="type">void</span> skiplist&lt;Key, Value, KeyOfValue, Compare&gt;::<span class="built_in">clear</span>() &#123;</span><br><span class="line">    <span class="comment">// 从第0层的头节点的后继开始</span></span><br><span class="line">    link_type node = header-&gt;forward[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        link_type tmp = node;</span><br><span class="line">        node = node-&gt;forward[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 销毁节点</span></span><br><span class="line">        <span class="built_in">destroy_node</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新初始化header的forward数组</span></span><br><span class="line">    <span class="built_in">bzero</span>(header-&gt;forward, <span class="built_in">sizeof</span>(link_type)*(top_level+<span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 重置最高层级和节点数量</span></span><br><span class="line">    top_level = <span class="number">0</span>;</span><br><span class="line">    node_count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="skip-set"><a href="#skip-set" class="headerlink" title="skip_set"></a>skip_set</h2><p><code>skip_set</code>的特性是所有元素都会根据元素的键值自动被排序，其元素不像<code>skip_map</code>那样可以同时具有实值和键值，<code>skip_set</code>元素的键值就是实值，实值就是键值，且不允许两个元素有相同的键值。受此影响，<code>skip_set</code>的迭代器被定义为底层<code>skiplist</code>的<code>const_iterator</code>，因为<code>skip_set</code>的元素值关系到其内部的排列规则，若随意修改元素值，会严重破坏<code>skip_set</code>的组织。</p>
<p><code>skip_set</code>以<code>skiplist</code>为底层机制，因此当对<code>skip_set</code>的元素进行增加或删除时，操作之前的所有迭代器在操作完成后依然有效，当然被删除的那个元素的迭代器除外。此外，由于<code>skip_set</code>所提供的各种操作接口，<code>skiplist</code>也都提供了，所以几乎所有的<code>skip_set</code>操作行为，都只需转调用<code>skiplist</code>的操作行为即可。以下是<code>skip_set</code>的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Compare = std::less&lt;Key&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> skip_set &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// set的key就是value</span></span><br><span class="line">        <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">        <span class="keyword">typedef</span> Key value_type;</span><br><span class="line">        <span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line">        <span class="keyword">typedef</span> Compare value_compare;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// 证同函数，任何数值通过此函数后，不会有任何改变</span></span><br><span class="line">        <span class="comment">// 作为跳表的KeyOfValue使用，因为set的value就是key</span></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">identity</span> : <span class="keyword">public</span> std::unary_function&lt;T, T&gt; &#123;</span><br><span class="line">            <span class="function"><span class="type">const</span> T&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 使用跳表作为set的底层容器</span></span><br><span class="line">        <span class="keyword">typedef</span> skiplist&lt;key_type, value_type, identity&lt;value_type&gt;, key_compare&gt; rep_type;</span><br><span class="line">        rep_type rep;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 不允许修改set已有元素，因为set的value就是key</span></span><br><span class="line">        <span class="comment">// 修改已有元素会破坏跳表结构，因此禁止通过迭代器进行写入</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer pointer;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer const_pointer;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference reference;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference const_reference;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator iterator;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator const_iterator;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::size_type size_type;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::difference_type difference_type;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数，默认的层数上限为18</span></span><br><span class="line">        <span class="built_in">skip_set</span>() : <span class="built_in">rep</span>(<span class="number">18</span>, <span class="built_in">Compare</span>()) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">skip_set</span><span class="params">(size_type max_level)</span> : rep(max_level, Compare()) &#123;</span>&#125;</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">skip_set</span><span class="params">(<span class="type">const</span> Compare &amp;comp)</span> : rep(<span class="number">18</span>, comp) &#123;</span>&#125;</span><br><span class="line">        <span class="built_in">skip_set</span>(size_type max_level, <span class="type">const</span> Compare &amp;comp) : <span class="built_in">rep</span>(max_level, comp) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 允许从一对迭代器[first, last)指示的范围来构造skip_set</span></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator&gt;</span><br><span class="line">        <span class="built_in">skip_set</span>(InputIterator first, InputIterator last)</span><br><span class="line">            : <span class="built_in">rep</span>(<span class="number">18</span>, <span class="built_in">Compare</span>()) &#123; rep.<span class="built_in">insert_unique</span>(first, last); &#125;</span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator&gt;</span><br><span class="line">        <span class="built_in">skip_set</span>(InputIterator first, InputIterator last, size_type max_level)</span><br><span class="line">            : <span class="built_in">rep</span>(max_level, <span class="built_in">Compare</span>()) &#123; rep.<span class="built_in">insert_unique</span>(first, last); &#125;</span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator&gt;</span><br><span class="line">        <span class="built_in">skip_set</span>(InputIterator first, InputIterator last, <span class="type">const</span> Compare &amp;comp)</span><br><span class="line">            : <span class="built_in">rep</span>(<span class="number">18</span>, comp) &#123; rep.<span class="built_in">insert_unique</span>(first, last); &#125;</span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator&gt;</span><br><span class="line">        <span class="built_in">skip_set</span>(InputIterator first, InputIterator last, size_type max_level, <span class="type">const</span> Compare &amp;comp)</span><br><span class="line">            : <span class="built_in">rep</span>(max_level, comp) &#123; rep.<span class="built_in">insert_unique</span>(first, last); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拷贝构造</span></span><br><span class="line">        <span class="built_in">skip_set</span>(<span class="type">const</span> skip_set&lt;Key, Compare&gt; &amp;rhs) : <span class="built_in">rep</span>(rhs.rep) &#123;&#125;</span><br><span class="line">        <span class="comment">// 赋值运算符</span></span><br><span class="line">        skip_set&lt;Key, Compare&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> skip_set&lt;Key, Compare&gt; &amp;rhs) &#123; rep = rhs.rep; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">        <span class="comment">// 交换操作</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(skip_set&lt;Key, Compare&gt; &amp;rhs)</span> </span>&#123; rep.<span class="built_in">swap</span>(rhs.rep); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转调用跳表的接口</span></span><br><span class="line">        <span class="function">key_compare <span class="title">key_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">key_comp</span>(); &#125;</span><br><span class="line">        <span class="function">value_compare <span class="title">value_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">key_comp</span>(); &#125;</span><br><span class="line">        <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">        <span class="function">const_iterator <span class="title">cbegin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">cbegin</span>(); &#125;</span><br><span class="line">        <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">end</span>(); &#125;</span><br><span class="line">        <span class="function">const_iterator <span class="title">cend</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">cend</span>(); &#125;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">        <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">size</span>(); &#125;</span><br><span class="line">        <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">max_size</span>(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入操作</span></span><br><span class="line">        <span class="function">std::pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type &amp;val)</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">insert_unique</span>(val); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator&gt;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(InputIterator first, InputIterator last)</span> </span>&#123; rep.<span class="built_in">insert_unique</span>(first, last); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除操作</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type &amp;k)</span> </span>&#123; rep.<span class="built_in">erase</span>(k); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator first, iterator last)</span> </span>&#123; rep.<span class="built_in">erase</span>(first, last); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清空操作</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; rep.<span class="built_in">clear</span>(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找操作</span></span><br><span class="line">        <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type &amp;k)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">find</span>(k); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载关系运算符的友元声明</span></span><br><span class="line">        <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==&lt;Key, Compare&gt;(<span class="type">const</span> skip_set&lt;Key, Compare&gt; &amp;lhs, <span class="type">const</span> skip_set&lt;Key, Compare&gt; &amp;rhs);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义重载的相等性判断运算符</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> skip_set&lt;Key, Compare&gt; &amp;lhs, <span class="type">const</span> skip_set&lt;Key, Compare&gt; &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.rep == rhs.rep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="skip-map"><a href="#skip-map" class="headerlink" title="skip_map"></a>skip_map</h2><p><code>skip_map</code>的特性是所有元素都会根据元素的键值自动被排序，元素类型为<code>pair</code>，同时拥有实值和键值。<code>pair</code>的第一元素为键值，第二元素为实值，<code>skip_map</code>不允许两个元素拥有相同的键值。<code>skip_map</code>不像<code>skip_set</code>那样将迭代器定义为<code>skiplist</code>的<code>const_iterator</code>，因为它允许通过迭代器修改元素的实值，但元素的键值关系到<code>skip_map</code>中元素的排列规则，任意改变其元素的键值将会严重破坏<code>skip_map</code>的组织，因此不能通过<code>skip_map</code>的迭代器来修改元素的键值。</p>
<p><code>skip_map</code>以<code>skiplist</code>为底层机制，因此当对<code>skip_map</code>的元素进行增加或删除时，操作之前的所有迭代器在操作完成后依然有效，当然被删除的那个元素的迭代器除外。此外，由于<code>skip_map</code>所提供的各种操作接口，<code>skiplist</code>也都提供了，所以几乎所有的<code>skip_map</code>操作行为，都只需转调用<code>skiplist</code>的操作行为即可。以下是<code>skip_map</code>的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Compare = std::less&lt;Key&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> skip_map &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 键值类型</span></span><br><span class="line">        <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">        <span class="comment">// 数据（实值）类型</span></span><br><span class="line">        <span class="keyword">typedef</span> T data_type;</span><br><span class="line">        <span class="keyword">typedef</span> T mapped_type;</span><br><span class="line">        <span class="comment">// 元素类型（键值/实值）</span></span><br><span class="line">        <span class="keyword">typedef</span> std::pair&lt;<span class="type">const</span> Key, T&gt; value_type;</span><br><span class="line">        <span class="comment">// 键值比较函数</span></span><br><span class="line">        <span class="keyword">typedef</span> Compare key_compare;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义嵌套类，只重载调用运算符，通过比较键值来判定元素的大小关系</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">value_compare</span> : <span class="keyword">public</span> std::binary_function&lt;value_type, value_type, <span class="type">bool</span>&gt; &#123;</span><br><span class="line">            <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">skip_map</span>&lt;Key, T, Compare&gt;;</span><br><span class="line">            <span class="keyword">protected</span>:</span><br><span class="line">                Compare comp;</span><br><span class="line">                <span class="built_in">value_compare</span>(Compare c) : <span class="built_in">comp</span>(c) &#123;&#125;</span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">                <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> value_type &amp;x, <span class="type">const</span> value_type &amp;y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">comp</span>(x.first, y.first); &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// 选择函数，接受一个pair，并返回其first成员</span></span><br><span class="line">        <span class="comment">// 作为跳表的KeyOfValue使用，因为map的key是元素的first成员</span></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Pair&gt;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">select1st</span> : <span class="keyword">public</span> std::unary_function&lt;Pair, <span class="keyword">typename</span> Pair::first_type&gt; &#123;</span><br><span class="line">            <span class="function"><span class="type">const</span> <span class="keyword">typename</span> Pair::first_type&amp; <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> Pair &amp;x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x.first; &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">typedef</span> skiplist&lt;key_type, value_type, select1st&lt;value_type&gt;, key_compare&gt; rep_type;</span><br><span class="line">        rep_type rep;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::pointer pointer;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_pointer const_pointer;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::reference reference;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_reference const_reference;</span><br><span class="line">        <span class="comment">// 允许通过迭代器来修改元素的实值，因此未定义为const_iterator</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::iterator iterator;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::const_iterator const_iterator;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::size_type size_type;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> rep_type::difference_type difference_type;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数，默认的层数上限为18</span></span><br><span class="line">        <span class="built_in">skip_map</span>() : <span class="built_in">rep</span>(<span class="number">18</span>, <span class="built_in">Compare</span>()) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">skip_map</span><span class="params">(size_type max_level)</span> : rep(max_level, Compare()) &#123;</span>&#125;</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">skip_map</span><span class="params">(<span class="type">const</span> Compare &amp;comp)</span> : rep(<span class="number">18</span>, comp) &#123;</span>&#125;</span><br><span class="line">        <span class="built_in">skip_map</span>(size_type max_level, <span class="type">const</span> Compare &amp;comp) : <span class="built_in">rep</span>(max_level, comp) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 允许从一对迭代器[first, last)指示的范围来构造skip_map</span></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator&gt;</span><br><span class="line">        <span class="built_in">skip_map</span>(InputIterator first, InputIterator last)</span><br><span class="line">            : <span class="built_in">rep</span>(<span class="number">18</span>, <span class="built_in">Compare</span>()) &#123; rep.<span class="built_in">insert_unique</span>(first, last); &#125;</span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator&gt;</span><br><span class="line">        <span class="built_in">skip_map</span>(InputIterator first, InputIterator last, size_type max_level)</span><br><span class="line">            : <span class="built_in">rep</span>(max_level, <span class="built_in">Compare</span>()) &#123; rep.<span class="built_in">insert_unique</span>(first, last); &#125;</span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator&gt;</span><br><span class="line">        <span class="built_in">skip_map</span>(InputIterator first, InputIterator last, <span class="type">const</span> Compare &amp;comp)</span><br><span class="line">            : <span class="built_in">rep</span>(<span class="number">18</span>, comp) &#123; rep.<span class="built_in">insert_unique</span>(first, last); &#125;</span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator&gt;</span><br><span class="line">        <span class="built_in">skip_map</span>(InputIterator first, InputIterator last, size_type max_level, <span class="type">const</span> Compare &amp;comp)</span><br><span class="line">            : <span class="built_in">rep</span>(max_level, comp) &#123; rep.<span class="built_in">insert_unique</span>(first, last); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拷贝构造</span></span><br><span class="line">        <span class="built_in">skip_map</span>(<span class="type">const</span> skip_map&lt;Key, T, Compare&gt; &amp;rhs) : <span class="built_in">rep</span>(rhs.rep) &#123;&#125;</span><br><span class="line">        <span class="comment">// 赋值运算符</span></span><br><span class="line">        skip_map&lt;Key, T, Compare&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> skip_map&lt;Key, T, Compare&gt; &amp;rhs) &#123; rep = rhs.rep; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">        <span class="comment">// 交换操作</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(skip_map&lt;Key, T, Compare&gt; &amp;rhs)</span> </span>&#123; rep.<span class="built_in">swap</span>(rhs.rep); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转调用跳表的接口</span></span><br><span class="line">        <span class="function">key_compare <span class="title">key_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">key_comp</span>(); &#125;</span><br><span class="line">        <span class="function">value_compare <span class="title">value_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">value_compare</span>(rep.<span class="built_in">key_comp</span>()); &#125;</span><br><span class="line">        <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">        <span class="function">const_iterator <span class="title">cbegin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">cbegin</span>(); &#125;</span><br><span class="line">        <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">end</span>(); &#125;</span><br><span class="line">        <span class="function">const_iterator <span class="title">cend</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">cend</span>(); &#125;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">        <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">size</span>(); &#125;</span><br><span class="line">        <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">max_size</span>(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入操作</span></span><br><span class="line">        <span class="function">std::pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type &amp;val)</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">insert_unique</span>(val); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator&gt;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(InputIterator first, InputIterator last)</span> </span>&#123; rep.<span class="built_in">insert_unique</span>(first, last); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除操作</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type &amp;k)</span> </span>&#123; rep.<span class="built_in">erase</span>(k); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator first, iterator last)</span> </span>&#123; rep.<span class="built_in">erase</span>(first, last); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清空操作</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; rep.<span class="built_in">clear</span>(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找操作</span></span><br><span class="line">        <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type &amp;k)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">find</span>(k); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载下标运算符</span></span><br><span class="line">        <span class="comment">// 先用value_type(k, T())构造一个临时的对象，再通过insert将其插入底层跳表</span></span><br><span class="line">        <span class="comment">// 若插入成功（元素key不存在于跳表），则新节点的实值为T的默认值并返回被插入节点的迭代器和true</span></span><br><span class="line">        <span class="comment">// 若插入失败（元素key已存在于跳表），则不修改key相同的节点的实值并返回该节点的迭代器和false</span></span><br><span class="line">        <span class="comment">// 因此对insert返回的pair对象中的first成员解引用可得到对含有目标key的节点的引用</span></span><br><span class="line">        <span class="comment">// 那么通过second成员，即可获得对该节点实值的引用，将其返回则可实现通过下标运算符设置元素实值</span></span><br><span class="line">        T&amp; <span class="keyword">operator</span>[](<span class="type">const</span> key_type &amp;k) &#123; <span class="keyword">return</span> (*((<span class="built_in">insert</span>(<span class="built_in">value_type</span>(k, <span class="built_in">T</span>()))).first)).second; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载关系运算符的友元声明</span></span><br><span class="line">        <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==&lt;Key, T, Compare&gt;(<span class="type">const</span> skip_map&lt;Key, T, Compare&gt; &amp;lhs, <span class="type">const</span> skip_map&lt;Key, T, Compare&gt; &amp;rhs);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义重载的相等性判断运算符</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> skip_map&lt;Key, T, Compare&gt; &amp;lhs, <span class="type">const</span> skip_map&lt;Key, T, Compare&gt; &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.rep == rhs.rep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="skiplist和RB-tree对比"><a href="#skiplist和RB-tree对比" class="headerlink" title="skiplist和RB-tree对比"></a>skiplist和RB-tree对比</h2><ul>
<li>在插入、删除、查找元素和有序输出所有元素方面，二者时间复杂度一致。</li>
<li>但若进行范围查找，<code>RB-tree</code>的效率不如<code>skiplist</code><ul>
<li><code>skiplist</code>只需定位最小值在最低层级（第$0$层）的位置，然后按序寻访若干步即可，十分高效。</li>
<li><code>RB-tree</code>则需定位到最小值后，还需以中序遍历的顺序从根节点继续寻找其他不超过最大值的节点。</li>
</ul>
</li>
<li><code>RB-tree</code>的插入&#x2F;删除可能引发子树的调整，逻辑复杂，而<code>skiplist</code>插入&#x2F;删除只需调整前驱和后继节点的连接，操作简单又便捷。因此对于并发环境来说，若发生插入&#x2F;删除，<code>skiplist</code>操作的更局部，需更新的部分少，锁的东西也就少。而<code>RB-tree</code>的平衡过程会牵扯到大量节点的调整，竞争锁的代价就更高了，因此性能自然不如<code>skiplist</code>。</li>
</ul>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>跳表</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程</title>
    <url>/2023/06/03/Fundamentals/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="1-网络编程的一般步骤"><a href="#1-网络编程的一般步骤" class="headerlink" title="1. 网络编程的一般步骤"></a>1. 网络编程的一般步骤</h2><ul>
<li>TCP<ul>
<li>服务端<ul>
<li><code>socket</code>创建套接字、<code>bind</code>绑定IP和端口号、<code>listen</code>监听连接请求</li>
<li><code>accept</code>受理连接请求，并返回新的套接字、在新的套接字上用<code>recv/send</code>收发数据、<code>close</code>关闭套接字</li>
</ul>
</li>
<li>客户端：<code>socket</code>创建套接字、<code>connect</code>发起连接请求、<code>recv/send</code>收发数据、<code>close</code>关闭套接字</li>
<li>其中客户端的<code>connect</code>和服务端的<code>accept</code>可能会阻塞程序，且客户端<code>connect</code>会引发三次握手，而服务端在<code>socket</code>、<code>bind</code>、<code>listen</code>后（三次握手完成），<code>accept</code>会返回一个<code>fd</code>，所以<code>accept</code>发生在三次握手之后。</li>
<li>避免<code>connect</code>方法长时间阻塞<ul>
<li>最常用也是最有效的方式就是加定时器，或者设置为非阻塞模式。</li>
<li>也可考虑采用异步传输机制，因为异步传输机制不同与同步传输，它可以立即返回。</li>
</ul>
</li>
</ul>
</li>
<li>UDP<ul>
<li>服务端：<code>socket</code>创建套接字、<code>bind</code>绑定IP和端口号、<code>recvfrom/sendto</code>收发数据、<code>close</code>关闭套接字</li>
<li>客户端：<code>socket</code>创建套接字、<code>recvfrom/sendto</code>收发数据、<code>close</code>关闭套接字</li>
</ul>
</li>
</ul>
<h2 id="2-主机字节序与网络字节序"><a href="#2-主机字节序与网络字节序" class="headerlink" title="2. 主机字节序与网络字节序"></a>2. 主机字节序与网络字节序</h2><ul>
<li>大端序：优先保存高位字节，即低位地址存放高位字节，网络字节序统一为大端序。</li>
<li>小端序：优先保存低位字节，即低位地址存放低位字节，x86为小端，arm默认为小端，且可手动设置为大端。</li>
<li>大小端检测：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">test</span> t;</span><br><span class="line">    t.a = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="keyword">if</span> (t.b == <span class="number">0x12</span>) std::cout &lt;&lt; <span class="string">&quot;大端序&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (t.b == <span class="number">0x78</span>) std::cout &lt;&lt; <span class="string">&quot;小端序&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>字节序转换：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="comment">// 长整型函数常用于转换IP地址</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title">htonl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> hostlong)</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title">ntohl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> netlong)</span></span>;</span><br><span class="line"><span class="comment">// 短整型函数常用于转换端口号</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="title">htons</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> hostshort)</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="title">ntohs</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> netshort)</span></span></span><br></pre></td></tr></table></figure>


<h2 id="3-IO多路复用"><a href="#3-IO多路复用" class="headerlink" title="3. IO多路复用"></a>3. IO多路复用</h2><ul>
<li>IO多路复用的原理是在一个进程（线程）中同时监听多个IO事件，从而避免为每个请求都分配一个进程（线程）。</li>
<li>在Linux中，IO复用的方式有<code>select</code>、<code>poll</code>、<code>epoll</code>这三个系统调用。</li>
<li><code>select</code><ul>
<li>将已连接的<code>socket</code>都放入一个文件描述符集合，通过遍历集合来检查是否有事件产生，时间复杂度为$O(N)$。</li>
<li>底层使用<code>BitMap</code>实现，因此文件描述符的个数会受到限制（默认最大为$1024$）。</li>
</ul>
</li>
<li><code>poll</code><ul>
<li>本质上与<code>select</code>无太大区别，都是使用线性结构存储文件描述符</li>
<li>但使用动态数组，从而突破了<code>select</code>的文件描述符个数限制，但仍会受到系统文件描述符个数限制。</li>
</ul>
</li>
<li><code>epoll</code><ul>
<li><code>epoll_create</code>创建<code>epoll</code>对象<code>epfd</code>，<code>epoll_ctl</code>将需监听的<code>socket</code>添加到<code>epfd</code>，<code>epoll_wait</code>等待事件。 </li>
<li>内核使用红黑树跟踪所有待检测的文件描述符，每次只需通过<code>epoll_ctl</code>传入一个待检测的文件描述符，无需像<code>select/poll</code>一样传入整个<code>socket</code>集合。</li>
<li><code>epoll_wait</code>采用回调的方式，内核检测到就绪事件，会触发回调函数来将其插入就绪事件队列，不需要像<code>select/poll</code>一样轮询整个<code>socket</code>集合，时间复杂度为$O(1)$。</li>
<li><code>epoll_wait</code>效率未必比<code>select/poll</code>高，当活动连接多时回调函数会被频繁触发，<code>epoll_wait</code>适用于连接多但活动少的情况。</li>
</ul>
</li>
</ul>
<h2 id="4-epoll中的LT和ET的区别"><a href="#4-epoll中的LT和ET的区别" class="headerlink" title="4. epoll中的LT和ET的区别"></a>4. epoll中的LT和ET的区别</h2><ul>
<li>两种模式的事件通知方式不同，<code>LT</code>持续通知直到事件处理完毕，<code>ET</code>只通知一次，不管事件是否处理完毕。</li>
<li><code>LT</code>模式下，读事件触发，可以按需收取字节数，不用一次性把数据收取干净；<code>ET</code>模式下，必须把数据收取干净。</li>
<li><code>LT</code>可自由决定每次收取多少数据，但可能导致多次触发；<code>ET</code>触发次数少效率更高，但每次都必须将数据接收完。</li>
</ul>
<h2 id="5-IO模型（粗分两种，细分五种）"><a href="#5-IO模型（粗分两种，细分五种）" class="headerlink" title="5. IO模型（粗分两种，细分五种）"></a>5. IO模型（粗分两种，细分五种）</h2><ul>
<li>同步IO：在IO事件发生后，由应用程序（用户）自行执行IO读写操作。<ul>
<li>阻塞&#x2F;非阻塞IO、信号驱动IO（进程运行并不阻塞，直到收到信号再处理IO事件）、IO复用。</li>
</ul>
</li>
<li>异步IO：由内核通过缓冲区位置直接对IO执行读写操作，且IO读写操作总是立即返回，不论IO是否阻塞。</li>
<li>简言之，同步IO向程序通知IO就绪事件，而异步IO则向程序通知IO完成事件。</li>
</ul>
<h2 id="6-事件处理模型Reactor-x2F-Proactor"><a href="#6-事件处理模型Reactor-x2F-Proactor" class="headerlink" title="6. 事件处理模型Reactor&#x2F;Proactor"></a>6. 事件处理模型Reactor&#x2F;Proactor</h2><ul>
<li>Reactor通常基于同步IO，Proactor则基于异步IO。</li>
<li>Reactor: 主线程只负责监听文件描述符上是否有事件发生，有就立刻通知工作线程，除此之外，主线程不做任何其他工作。</li>
<li>Proactor: 主线程执行数据读写操作，读写完成后，主线程向工作线程通知完成事件，那么从工作线程角度来看，它已经获得数据读写的结果，接下来就只要对读写结果进行逻辑处理即可。</li>
</ul>
<h2 id="7-并发编程模式"><a href="#7-并发编程模式" class="headerlink" title="7. 并发编程模式"></a>7. 并发编程模式</h2><ul>
<li>并发编程模式是指IO处理单元和多个逻辑单元间协调完成工作，主要有半同步&#x2F;半异步模式和领导者&#x2F;追随者模式。<ul>
<li>半同步&#x2F;半异步模式：<ul>
<li>与IO同步&#x2F;异步概念不同，此处同步指程序完全按代码的顺序执行，异步则指程序的执行需由系统事件（中断&#x2F;信号等）驱动。异步效率高，实时性强，适合嵌入式，但复杂难调试，不适于大量并发。同步效率相对较低，但逻辑简单。因此对于服务器这种既要求实时性，又要求并发，就该同时使用同步线程和异步线程。</li>
<li>在半同步&#x2F;半异步模式中，异步线程处理IO事件（监听客户请求）并插入请求队列，然后通过同步线程读取并处理请求对象。结合考虑事件处理模式（Reactor&#x2F;Proactor）和IO模型（同步&#x2F;异步IO），则半同步&#x2F;半异步模式就存在多种变体。<ul>
<li>半同步&#x2F;半反应堆：异步线程只有主线程，负责监听<code>socket</code>事件并插入连接到请求队列，工作线程处理队列中的任务。  <div align="center" style=transform:scale(0.7)>
  <img src="/images/半同步半反应堆模式.png"/>
  </div></li>
<li>高效半同步&#x2F;半异步模式：主线程只管理监听<code>socket</code>，连接<code>socket</code>由工作线程管理，无请求队列，因此没有对队列进行存取时的加锁操作，从而提高效率。每个线程都工作在异步模式，所以非严格意义上的半同步&#x2F;半异步模式。  <div align="center" style=transform:scale(0.7)>
  <img src="/images/高效的半同步半异步模式.png"/>
  </div></li>
</ul>
</li>
</ul>
</li>
<li>领导者&#x2F;追随者模式：<ul>
<li>任意时间点，只有一个领导者，负责监听IO事件，其他线程为追随者。若当前领导者检测到IO事件，首先从线程池推举出新领导者，然后再处理IO事件。此时新领导者等待新IO事件，旧领导者处理先前的IO事件，二者实现并发。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="8-多进程和多线程的区别"><a href="#8-多进程和多线程的区别" class="headerlink" title="8. 多进程和多线程的区别"></a>8. 多进程和多线程的区别</h2><ul>
<li>线程是轻量级的进程，执行效率和进程差不多，但消耗的系统资源更少。</li>
<li>进程有自己独立的地址空间，多个线程共用同一个地址空间。<ul>
<li>同一地址空间线程独享：栈区、寄存器（内核中管理）</li>
<li>同一地址空间线程共享：代码段、堆区、全局数据区、打开的文件（文件描述符表）</li>
</ul>
</li>
<li>进程是资源分配的最小单位，线程是操作系统调度的最小单位。<ul>
<li>每个进程对应一个虚拟空间，一个进程只能抢占一个CPU时间片。</li>
<li>一个地址空间可划分出多个线程，在有效资源的基础上，可抢占更多CPU时间片。</li>
</ul>
</li>
<li>CPU的调度和切换：线程上下文切换比进程要快的多<ul>
<li>上下文切换：进程&#x2F;线程分时复用时间片，切换前会将任务的状态保存，下次切换回该任务会重新加载状态。</li>
</ul>
</li>
<li>多任务程序优先使用线程，但线程也不是越多越好。<ul>
<li>文件IO操作：文件IO对CPU使用率不高，因此可分时复用时间片，$线程数&#x3D;2 * CPU核心数$。</li>
<li>处理复杂算法：CPU进行运算，压力大，$线程数&#x3D;CPU核心数$。</li>
</ul>
</li>
<li>两者各有优缺点，线程开销小，但不利于资源管理和保护，进程恰好相反。同时线程适合于在多处理器机器上运行，而进程则可以跨机器迁移。</li>
<li>使用<code>fork</code>函数后，得到的子进程将会拥有父进程的几乎一切资源，但是父子进程都拥有各自的全局变量，不能通用。而对于线程来说，各线程会共享全局变量。</li>
</ul>
<h2 id="9-线程的相关操作"><a href="#9-线程的相关操作" class="headerlink" title="9. 线程的相关操作"></a>9. 线程的相关操作</h2><ul>
<li>线程创建函数<ul>
<li>每个线程都有<code>ID</code>，类型为<code>pthread_t</code>，可通过<code>pthread_self</code>函数获得。</li>
<li><code>pthread_create</code>创建新线程，传入参数线程<code>ID</code>、线程属性（<code>NULL</code>）、回调函数、回调函数参数。</li>
</ul>
</li>
<li>线程退出函数<ul>
<li><code>pthread_exit</code>让线程退出，但不释放虚拟地址空间（针对于主线程），且不影响其他线程。</li>
<li><code>pthread_exit</code>参数为<code>void*</code>，线程退出时可携带数据，主线程会得到该数据，若不要，则设置为<code>NULL</code>即可。</li>
<li>若主线程调用<code>pthread_exit</code>，也不会影响尚未执行完的子线程，否则（主线程既不执行<code>pthread_exit</code>也不执行<code>pthread_join</code>）有可能主线程先抢到时间片，执行完后就立即释放了虚拟地址空间（子线程资源），那么子线程尚未执行就结束了。</li>
</ul>
</li>
<li>线程回收函数<ul>
<li><code>pthread_join</code>会阻塞等待线程退出，且每次只回收一个子线程。</li>
<li>参数为<code>pthread_t</code>线程<code>ID</code>以及<code>void**</code>用于接受子线程通过<code>pthread_exit</code>退出时携带的参数（必须为全局变量&#x2F;堆变量&#x2F;主线程栈变量（得在创建子线程时设置回调函数参数），否则若为子线程栈变量则由子线程独享，子线程结束就会释放）。</li>
</ul>
</li>
<li>线程分离函数<ul>
<li>因为<code>pthread_join</code>会让主线程阻塞以回收子线程资源，而某些情况下可能不希望主线程阻塞。</li>
<li>调用<code>pthread_detach</code>会让子线程和主线程分离，当子线程退出，其占用资源无需主线程回收，且主线程中使用<code>pthread_join</code>也回收不到子线程资源。</li>
<li>若主线程结束，被分离出去的子线程也无法存活，因为主线程释放了虚拟地址空间，因此必须在主线程中调用<code>pthread_exit</code>进行退出，而不能直接<code>retrun</code>。</li>
</ul>
</li>
<li>线程取消函数<ul>
<li><code>pthread_cancel</code>通过参数（线程<code>ID</code>）指定要杀死的线程，返回值<code>0</code>或<code>1</code>。</li>
<li>但线程不会被立马杀死，通常需要满足指定条件，即将被杀死的线程中需进行一次系统调用（从用户区切换到内核区），否则该线程能一直运行。</li>
</ul>
</li>
<li>线程比较函数<ul>
<li><code>pthread_equal</code>，参数为两个线程<code>ID</code>，相等则返回非零值，其实直接将<code>ID</code>做整型值比较也可以。</li>
</ul>
</li>
</ul>
<h2 id="10-线程同步"><a href="#10-线程同步" class="headerlink" title="10. 线程同步"></a>10. 线程同步</h2><ul>
<li>概念：不是让线程并行地执行，而是线性（先后顺序）地执行。</li>
<li>方式<ul>
<li>互斥锁（<code>pthread_mutex_t mutex</code>）：锁的所有权只能被一个线程所拥有<ul>
<li><code>pthread_mutex_init</code>初始化互斥锁，参数分别为互斥锁地址（<code>&amp;mutex</code>）及其属性（一般为<code>NULL</code>）</li>
<li><code>pthread_mutex_destroy</code>释放互斥锁，参数为互斥锁地址（<code>&amp;mutex</code>）</li>
<li><code>pthread_mutex_lock</code>加锁操作，参数为互斥锁地址（<code>&amp;mutex</code>）</li>
<li><code>pthread_mutex_unlock</code>解锁操作，参数为互斥锁地址（<code>&amp;mutex</code>）</li>
<li><code>pthread_mutex_trylock</code>尝试加锁，若已经被其他线程锁上，则非阻塞，并返回错误号。</li>
</ul>
</li>
<li>死锁：所有线程被阻塞，且线程的阻塞无法解开（因为可以解锁的线程也被阻塞了）<ul>
<li>场景1: 加锁后忘记解锁</li>
<li>场景2: 临界区内部在解锁前有<code>return</code>操作（C++中可通过<code>RAII</code>的<code>lock_guard</code>来解决，<code>return</code>时会自动调用析构解锁；也可使用更灵活的<code>unique_lock</code>，<code>lock_guard</code>只有在超出对象作用域时，才会通过析构解锁；而<code>unique_lock</code>除了超出作用域时的自动析构解锁，还可以调用<code>unlock</code>成员函数手动解锁，且会<code>unlock</code>根据锁的状态来判断是否需要真的解锁。）</li>
<li>场景3: 重复加锁造成死锁</li>
<li>场景4: 多个共享资源，多把锁，随意加锁（加锁顺序不对）导致相互被阻塞</li>
</ul>
</li>
<li>死锁避免<ul>
<li>避免多次锁定，多检查</li>
<li>对共享资源访问完毕，一定要解锁，或者加锁时使用<code>trylock</code></li>
<li>若程序有多把锁，可以控制对锁的访问顺序，也可在对其他锁加锁前，先释放当前线程所拥有的互斥锁。</li>
<li>可以引入一些专门用于死锁检测的模块。</li>
</ul>
</li>
<li>读写锁：互斥锁的升级版本<ul>
<li>在做读操作的时候可提高程序效率，若所有线程都做读操作，那么读是并行的，而互斥锁，读是串行的。</li>
<li>读写锁类型为<code>pthread_rwlock_t</code>，是一把锁，但能既提供锁定读又能提供锁定写的操作。</li>
<li>若读锁锁定临界区，线程对临界区的访问是并行的，读锁是共享的。</li>
<li>若写锁锁定临界区，线程对临界区的访问是串行的，写锁是独占的。</li>
<li>使用读写锁对临界区分别加了读锁和写锁，两个线程同时访问临界区，访问写锁临界区的线程继续运行，访问读锁临界区的线程阻塞，因为写锁优先级比读锁高。</li>
<li>若所有线程都对共享资源做写操作，使用读写锁无优势，此时就是互斥锁，但若所有对共享资源有读也有写，且读操作越多，读写锁越有优势。</li>
</ul>
</li>
<li>条件变量<ul>
<li>严格意义上，条件变量的主要作用不是处理线程同步，而是进行线程阻塞。在多线程中必须搭配互斥锁才能实现线程同步。虽然条件变量和互斥锁都可执行线程阻塞，但二者效果是不一样的。互斥锁：一个线程加锁成功，其余线程均阻塞。条件变量：只有在满足指定条件下才会阻塞线程，若不满足则多个线程可同时进入临界区，同时读写临界资源。 这种情况下还是会出现共享资源数据的混乱。</li>
<li>条件变量主要用于处理生产者&#x2F;消费者模型，并配合互斥锁使用，类型为<code>pthread_cond_t</code>。</li>
<li>需要一个容器，若容器空，则阻塞所有消费者线程，生成者每向容器中添加一个元素，就可执行一次唤醒提醒消费者。若容器满，则阻塞所有生产者线程，消费者从容器中取元素，就可执行一次唤醒提醒生产者。</li>
<li><code>pthread_cond_init</code>和<code>pthread_cond_destroy</code>初始化和销毁条件变量，生产者和消费者不能使用同一个条件变量。</li>
<li><code>pthread_cond_wait</code>阻塞线程，若该线程是加锁状态，就会自动解锁，若线程解除阻塞，则再次加锁，加锁成功才会继续向下执行临界区，参数为条件变量和一个互斥锁。</li>
<li><code>pthread_cond_timewait</code>将线程阻塞一定时间长度，时间到达就解开阻塞，参数会多一个超时时长。</li>
<li><code>pthread_cond_signal</code>唤醒阻塞在条件变量上的线程，至少一个被解除阻塞。</li>
<li><code>pthread_cond_broadcast</code>唤醒阻塞在条件变量上的线程，被阻塞线程全部被解除阻塞。</li>
</ul>
</li>
<li>信号量<ul>
<li>比条件变量更简单，无需自己进行条件判定。生产者和消费者可拥有各自的信号量，也可拥有相同信号量。</li>
<li><code>sem_init</code>初始化信号量，参数为信号量，<code>pshared</code>（线程同步<code>0</code>，进程同步<code>1</code>），初始值（拥有资源数）。</li>
<li><code>sem_destroy</code>销毁信号量，参数为信号量。</li>
<li><code>sem_wait</code>相当于P操作<code>-1</code>，取资源，若信号量为<code>0</code>（资源耗尽）则阻塞，<code>sem_trywait</code>非阻塞式。</li>
<li><code>sem_post</code>相当于V操作<code>+1</code>，存资源。</li>
<li><code>sem_getvalue</code>获取信号量（资源数量），参数为信号量和保存资源数的地址（传出参数）。</li>
<li>资源量为<code>1</code>时，可不加锁，若资源量<code>&gt;1</code>，则要加锁。且加锁操作只能在<code>sem_wait</code>下面，否则可能会死锁。</li>
</ul>
</li>
<li>原子变量<ul>
<li>C++11提供原子类型模板<code>std::atomic</code>，通过该原子类型所管理的变量就是原子变量，保证读写都互斥。</li>
<li>原子操作不会被线程调度机制打断，中间不会有任何上下文切换，从而保证多线程访问共享资源不会出现数据混乱。</li>
<li>原子操作是无锁类型，通过指令提供支持，因此性能优于锁和消息传递，且无需开发者处理加锁解锁问题。</li>
<li>原子类型内部使用CAS（Compare And Swap）循环机制，通过不断赋值来竞争资源，若赋值成功，则表示竞争到了资源。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="11-HTTP长连接和TCP长连接"><a href="#11-HTTP长连接和TCP长连接" class="headerlink" title="11. HTTP长连接和TCP长连接"></a>11. HTTP长连接和TCP长连接</h2><ul>
<li>HTTP的Keep-Alive是由应用层（用户态）实现的，称为HTTP长连接，通过复用同一个TCP连接来收发多个HTTP请求&#x2F;应答，从而避免连接建立和释放的开销。</li>
<li>从HTTP1.1开始是默认开启长连接的，若要手动管理，则需设置HTTP请求包头部中的<code>Connection: keep-alive/close</code>字段，且必须保证服务端和客户端设置一致。</li>
<li>HTTP长连接由服务端的定时器管理，如设置超时时长为60秒，且客户端在60秒内未发起新请求，则会触发回调函数释放该连接。</li>
<li>TCP的Keep-Alive是由TCP层（内核态）实现的，称为TCP保活机制，当客户端与服务端在一定时间内没有数据交互，内核为确保该连接是否有效，就会发送探测报文来检测对方是否在线，然后再决定是否要关闭该连接。</li>
</ul>
<h2 id="12-客户端突然掉线或重启"><a href="#12-客户端突然掉线或重启" class="headerlink" title="12. 客户端突然掉线或重启"></a>12. 客户端突然掉线或重启</h2><ul>
<li>若客户端掉线或重启，服务端就会收到复位信号，由于每一种TCP&#x2F;IP的实现方式不一样，因此控制机制也不一样。</li>
<li>可以在<code>socket</code>编程中使用定时器（适合有数据流动的情况），或使用<code>socket</code>选项中的<code>SO_KEEPALIVE</code>（适合没有数据流动的情况）来让服务器得知客户端状态。</li>
</ul>
<h2 id="13-TTL的概念及用处"><a href="#13-TTL的概念及用处" class="headerlink" title="13. TTL的概念及用处"></a>13. TTL的概念及用处</h2><ul>
<li>TTL时Time To Live，在每经过一个路由就会减去1，若减至0，数据包就被会丢掉。它的主要目的在于防止数据包在有回路的网路上死转，浪费网络资源，<code>ping</code>命令和<code>traceroute</code>会用到它。</li>
</ul>
<h2 id="14-TCP重传机制的实现"><a href="#14-TCP重传机制的实现" class="headerlink" title="14. TCP重传机制的实现"></a>14. TCP重传机制的实现</h2><ul>
<li>使用滑动窗口机制来确定收发的边界，可以让发送方知道已经发送的（已确认）字节数，尚未确认的字节数、待发送的字节数；可以让接收方知道已经确认收到的字节数。</li>
<li>使用选择重传机制来对传输出错的序列进行重传。</li>
</ul>
<h2 id="15-TCP三次握手（而不是两次）"><a href="#15-TCP三次握手（而不是两次）" class="headerlink" title="15. TCP三次握手（而不是两次）"></a>15. TCP三次握手（而不是两次）</h2><ul>
<li>假设A和B两个进程通信，若只是两次连接，则可能出现一种情况：A发送完请求报文后，由于网络拥塞的原因，使得B延迟了很久才收到请求报文，此时A则会认为发出的请求报文已经失效。</li>
<li>而B收到请求报文后，会向A发起连接，那么此时两次握手完毕，B会认为此时已经建立了可以通信的连接，并一直等待A发送的连接请求，但此时A并不会处理已失效的报文的回复。因此B会陷入忙等的僵局，造成资源的浪费。</li>
</ul>
<h2 id="16-TCP字节流和UDP数据报的区别"><a href="#16-TCP字节流和UDP数据报的区别" class="headerlink" title="16. TCP字节流和UDP数据报的区别"></a>16. TCP字节流和UDP数据报的区别</h2><ul>
<li>TCP是面向连接的，数据在连接上流动，没有边界，发送方<code>write</code>的调用次数和接收方<code>read</code>的调用次数不必相同。</li>
<li>UDP是无连接的，每个数据包都是独立的，存在边界，且每次只能读取一个报文，报文和报文是不会合并的，发送方<code>wirte</code>的调用次数和接收方<code>read</code>的调用次数必须一致。</li>
</ul>
<h2 id="17-GET和POST的区别"><a href="#17-GET和POST的区别" class="headerlink" title="17. GET和POST的区别"></a>17. GET和POST的区别</h2><ul>
<li>GET相比POST更不安全，因为它的参数直接暴露在URL上，而POST则是放在请求报文的请求主体中。</li>
<li>由于URL在不同的浏览器上会有不同的长度限制，因此GET可传递的数据也会受到长度限制，而POST则不会。</li>
<li>GET的参数会被浏览器主动缓存，而POST不会；GET只能进行URL编码，而POST支持多种编码方式。</li>
<li>在参数类型上，GET只支持ASCII字符，而POST无限制。浏览器回退时GET是无害的，POST会再次提交请求。</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面向对象</title>
    <url>/2023/05/24/CPP/CPP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="1-面向对象的特性"><a href="#1-面向对象的特性" class="headerlink" title="1. 面向对象的特性"></a>1. 面向对象的特性</h2><ul>
<li>封装：⼀个类就是⼀个封装了数据以及操作这些数据的逻辑实体，并通过访问说明符对成员的可访问性加以限定。</li>
<li>继承：派生类可以使用父类的所有功能，且可以对父类的功能进行扩展。</li>
<li>多态：<ul>
<li>编译时多态：函数重载、模板</li>
<li>运行时多态：派生类重写父类的虚函数，并用父类指针指向派生类对象，从而在运行时决定所调用的函数。</li>
</ul>
</li>
</ul>
<h2 id="2-类与类之间的关系"><a href="#2-类与类之间的关系" class="headerlink" title="2. 类与类之间的关系"></a>2. 类与类之间的关系</h2><ul>
<li><code>is-a</code>：继承关系，具有传递性。</li>
<li><code>has-a</code>：一个类包含另一个类，即类的成员是另一个已经定义好的类。</li>
<li><code>use-a</code>：一个类使用另一个类，通过定义友元或参数传递实现类之间的成员函数相互联系。</li>
</ul>
<h2 id="3-多重继承存在的问题"><a href="#3-多重继承存在的问题" class="headerlink" title="3. 多重继承存在的问题"></a>3. 多重继承存在的问题</h2><ul>
<li>增加程序复杂度，使程序难于维护，容易出错。但可用于抽象基类，以实现接口继承。</li>
<li>若基类之间或基类和派生类之间存在同名成员，则将会出现同名二义性问题。<ul>
<li>可利用作用域运算符，显示指定使用哪个类的成员。</li>
<li>在派生类中定义同名成员，覆盖基类中的相关成员。</li>
</ul>
</li>
<li>若派生类从多个基类派生，而这些基类又从同一基类派生（钻石继承），则访问共同基类成员时会出现路径二义性。<ul>
<li>使用虚继承，使得从不同路径继承而来的同名成员在内存中只有一份拷贝。</li>
</ul>
</li>
</ul>
<h2 id="4-重载、重写、覆盖的区别"><a href="#4-重载、重写、覆盖的区别" class="headerlink" title="4. 重载、重写、覆盖的区别"></a>4. 重载、重写、覆盖的区别</h2><ul>
<li>重载<code>overload</code>：指函数名相同，但参数列表不同，可以是参数类型，个数，顺序不同，不关心返回类型。</li>
<li>重写<code>override</code>：指在派生类中重新定义与父类中完全相同的虚函数，被重写函数不能为<code>static</code>，一定得是虚函数。</li>
<li>覆盖：指在派生类中重新定义（隐藏）与父类中同名的非虚函数，且参数列表和返回类型和父类完全相同。</li>
</ul>
<h2 id="5-虚函数的实现原理"><a href="#5-虚函数的实现原理" class="headerlink" title="5. 虚函数的实现原理"></a>5. 虚函数的实现原理</h2><ul>
<li>当⼀个类中包含虚函数时，编译器会为该类生成⼀个虚函数表，保存该类中虚函数的地址，编译器检测类型有虚函数，会为类对象生成⼀个虚函数表指针，指向该类型的虚函数表，虚函数指针的初始化是在构造函数中完成的。</li>
<li>后续如果有⼀个基类指针指向派生类对象，那么当调用虚函数时，就会根据所指真正对象的虚函数表指针去寻找虚函数的地址，也就可以调用派生类的虚函数表中的虚函数以此实现多态。</li>
<li>虚函数表是针对于类的，类的不同对象共享同一个虚函数表，但每个对象内部指向虚函数表的指针<code>vptr</code>是不同的。</li>
</ul>
<h2 id="6-编译器生成虚函数表的步骤"><a href="#6-编译器生成虚函数表的步骤" class="headerlink" title="6. 编译器生成虚函数表的步骤"></a>6. 编译器生成虚函数表的步骤</h2><ul>
<li>拷⻉基类的虚函数表，如果是多继承，就拷⻉每个有虚函数基类的虚函数表。</li>
<li>查看派生类是否重写基类中的虚函数，如果有，就替换成已经重写的虚函数地址；查看派生类是否有自身的虚函数，如果有，就追加自身的虚函数到自身的虚函数表中。</li>
</ul>
<h2 id="7-构造和析构中的虚函数"><a href="#7-构造和析构中的虚函数" class="headerlink" title="7. 构造和析构中的虚函数"></a>7. 构造和析构中的虚函数</h2><ul>
<li>构造函数不能定义为虚函数，虚函数的调用依赖于虚函数表，而指向虚函数表的指针<code>vptr</code>需在构造函数中初始化。</li>
<li>基类的析构函数需定义为虚函数以实现多态调用时，正确析构对象，否则会导致派生类对象的基类部分已释放，但派生类新增的数据成员无法释放。</li>
</ul>
<h2 id="8-不能为虚函数的函数"><a href="#8-不能为虚函数的函数" class="headerlink" title="8. 不能为虚函数的函数"></a>8. 不能为虚函数的函数</h2><ul>
<li>构造函数：如上所述。</li>
<li>内联函数：内联函数在编译期进行函数体替换操作，属于静态绑定，而虚函数是运行时确定类型，即动态绑定。</li>
<li>静态函数：静态成员函数没有<code>this</code>指针，只能通过类名调用，无法实现运行时多态。</li>
<li>友元或普通函数：友元或普通函数均不属于成员函数，不能被继承，不在继承体系中的函数没有虚函数的说法。</li>
</ul>
<h2 id="9-纯虚函数"><a href="#9-纯虚函数" class="headerlink" title="9. 纯虚函数"></a>9. 纯虚函数</h2><ul>
<li>声明纯虚函数<code>virtual func(...) = 0;</code>，目的在于让派生类继承函数的接口，且派生类中必须实现该纯虚函数，否则含有纯虚函数的类为抽象类，无法实例化对象。</li>
<li>纯虚函数可提供实现代码，但由于抽象类无法实例化，调用该实现的唯一方式就是在派生类中通过抽象类名来调用。</li>
</ul>
<h2 id="10-编译器默认合成的函数"><a href="#10-编译器默认合成的函数" class="headerlink" title="10. 编译器默认合成的函数"></a>10. 编译器默认合成的函数</h2><ul>
<li>默认构造函数，且若用户自定义了构造函数，则不会默认合成。</li>
<li>拷贝构造、赋值运算符、析构函数、取地址运算符、<code>const</code>修饰的取地址运算符。</li>
<li>对于移动构造&#x2F;赋值，若自定义了拷贝构造、拷贝赋值或析构函数中的任何一个，编译器就不会合成移动操作。</li>
</ul>
<h2 id="11-构造函数"><a href="#11-构造函数" class="headerlink" title="11. 构造函数"></a>11. 构造函数</h2><ul>
<li>无参构造函数（或所有参数都提供了默认值）：即默认构造函数，若未自定义任何构造函数，则编译器会默认合成。</li>
<li>一般构造函数：也称重载构造函数，一个类可以有多个一般构造函数，前提是参数列表不同。</li>
<li>拷贝构造函数：参数为对象本身的引用，若未自定义则编译器会默认合成。类若有指针成员，最好不要用默认版本。</li>
<li>移动构造函数：参数为对象本身的右值引用，若未自定义，则编译器会默认合成。</li>
<li>转换构造函数：根据一个指定类型对象来创建一个本类对象，可用于隐式转换，可声明<code>explicit</code>以禁止隐式转换。</li>
<li>委托构造函数：指当前的构造函数可以将成员初始化的工作委托给其他的构造函数。</li>
<li>赋值运算符：若左右两侧对象都已创建，则使用赋值运算符，若左侧对象尚未创建，则调用拷贝构造。</li>
</ul>
<h2 id="12-成员初始化列表"><a href="#12-成员初始化列表" class="headerlink" title="12. 成员初始化列表"></a>12. 成员初始化列表</h2><ul>
<li>对于引用类型的成员变量或者是<code>const</code>修饰的成员变量，必须使用成员初始化列表。</li>
<li>基类部分的初始化必须在进入派生类构造函数前完成，因此必须在成员初始化列表中调用基类构造函数。</li>
<li>成员的初始化顺序与其在类中的声明顺序一致，而与在成员初始化列表中的顺序无关。</li>
</ul>
<h2 id="13-构造和析构的执行顺序"><a href="#13-构造和析构的执行顺序" class="headerlink" title="13. 构造和析构的执行顺序"></a>13. 构造和析构的执行顺序</h2><ul>
<li>若存在继承，则构造函数先调用基类构造函数来构造基类的部分，再构造派生类新增的部分，而析构函数则相反，先析构派生类新增的部分，再调用基类析构函数析构基类部分。</li>
<li>若有多个基类，则基类构造函数的调用顺序是基类在派生类列表中的声明顺序，而不是成员初始化列表的顺序。</li>
<li>对于类的成员变量，它们在类中的初始化顺序和它们在类中的声明顺序一致，而不是成员初始化列表的顺序。</li>
</ul>
<h2 id="14-构造-x2F-析构函数与异常"><a href="#14-构造-x2F-析构函数与异常" class="headerlink" title="14. 构造&#x2F;析构函数与异常"></a>14. 构造&#x2F;析构函数与异常</h2><ul>
<li>从语法角度，构造函数可以抛出异常，但在实际应用中，应该尽量避免抛出异常，否则可能导致内存泄漏。</li>
<li>析构函数不能抛出异常，因为当抛出异常时，会在异常抛出点执行栈解退，若异常抛出点之后的程序存在释放内存等操作，则不会被执行，从而导致内存泄漏。</li>
</ul>
<h2 id="15-四种强制类型转换"><a href="#15-四种强制类型转换" class="headerlink" title="15. 四种强制类型转换"></a>15. 四种强制类型转换</h2><ul>
<li><code>static_cast</code>：显式类型转换，没有动态类型检查，上行转换（派生类-&gt;基类）安全，下行转换（基类-&gt;派生类） 不安全，所以主要执行非多态的转换操作；</li>
<li><code>dynamic_cast</code>：主要用于运行时从基类指针&#x2F;引用向派生类指针&#x2F;引用转换，若转换失败，对于指针会返回<code>nullptr</code>，对于引用则会抛出<code>bad_cast</code>异常。</li>
<li><code>const_cast</code>：主要用于去除指针或引用类型的<code>const</code>属性，可能会导致未定义行为，需要慎用。</li>
<li><code>reinterpret_cast</code>：几乎什么都可以转，从底层对数据进行重新解释，依赖于平台，可移植性差。</li>
</ul>
<h2 id="16-静态绑定和动态绑定"><a href="#16-静态绑定和动态绑定" class="headerlink" title="16. 静态绑定和动态绑定"></a>16. 静态绑定和动态绑定</h2><ul>
<li>静态绑定（早绑定）：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型（声明时所采用的类型），发生在编译期间，如非虚函数，以及函数的缺省参数值等。</li>
<li>动态绑定（晚绑定）：绑定的是动态类型，所对应的函数或属性依赖于动态类型（所指对象的实际类型，在运行期间确定），发生在运行期间，如虚函数。</li>
<li>不应重写父类的缺省参数，如在派生类中重写虚函数的缺省参数， 但缺省参数值实际上是静态绑定，与静态类型相关。因此当使用基类指针指向派生类对象进行多态调用时，所使用的缺省参数值仍是基类中的部分，与预期不符。</li>
</ul>
<h2 id="17-深拷贝和浅拷贝"><a href="#17-深拷贝和浅拷贝" class="headerlink" title="17. 深拷贝和浅拷贝"></a>17. 深拷贝和浅拷贝</h2><ul>
<li>以赋值运算符为例，若未显示定义该对象的赋值操作，则编译器会默认合成一个拷贝赋值运算符以对类的数据成员进行一一复制，这属于浅拷贝。当数据成员不是指针类型时，浅拷贝可行。</li>
<li>若存在指针类型的数据成员，且该成员指向动态分配的内存，如果继续使用浅拷贝，则会导致左右两侧对象的指针成员指向同一内存位置，不仅会导致在对象被析构时，右侧对象动态分配的内存会被重复释放，而且赋值前左侧对象的动态内存无法释放，致使内存泄漏。</li>
<li>针对于此中情况，就应该使用深拷贝以复制指针成员所管理的底层资源。当然还有一种情况，可对指针成员进行浅拷贝，就是需要进行资源共享时，如<code>shared_ptr</code>。</li>
</ul>
<h2 id="18-调用拷贝构造函数的三种情况"><a href="#18-调用拷贝构造函数的三种情况" class="headerlink" title="18. 调用拷贝构造函数的三种情况"></a>18. 调用拷贝构造函数的三种情况</h2><ul>
<li>对象以值传递的方式传入函数体时，或是以值传递从函数返回，都需要调用拷贝构造以创建一个临时对象。</li>
<li>当一个对象需要通过另一个同类对象进行初始化时。</li>
</ul>
<h2 id="19-RTTI概念及原理"><a href="#19-RTTI概念及原理" class="headerlink" title="19. RTTI概念及原理"></a>19. RTTI概念及原理</h2><ul>
<li>RTTI是指运行时类型识别，其功能由<code>typeid</code>和<code>dynamic_cast</code>这两个运算符实现。</li>
<li><code>typeid</code>：用于返回表达式的类型，可通过基类指针获取派生类的数据类型。</li>
<li><code>dynamic_cast</code>：具有类型检查功能，用于将基类指针&#x2F;引用安全地转换为派生类指针&#x2F;引用。</li>
</ul>
<h2 id="20-C-11新特性"><a href="#20-C-11新特性" class="headerlink" title="20. C++11新特性"></a>20. C++11新特性</h2><ul>
<li>提高运行效率：右值引用、泛化常量表达式</li>
<li>增强原有语法的使用性：成员初始化列表、类型推断、范围<code>for</code>循环、<code>Lambda</code>表达式、委托构造函数以及<code>final</code>、<code>override</code>、<code>delete</code>、<code>default</code>这些用于修饰成员函数的关键字。</li>
<li>标准库更新：智能指针、正则表达式、无序关联容器等。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（上篇）</title>
    <url>/2023/06/06/Fundamentals/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a><a href="https://www.bilibili.com/video/BV1Yr4y157Ci/?p=2&spm_id_from=pageDriver&vd_source=65122611208f4d2dd8e86fb48f5e4e28">面向对象设计原则</a></h2><ul>
<li><p>依赖倒置原则（DIP）</p>
<ul>
<li>高层模块（稳定）不应该依赖低层模块（变化），二者都应该依赖于抽象（稳定）。</li>
<li>抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）。</li>
</ul>
</li>
<li><p>开放封闭原则（OCP）</p>
<ul>
<li>类模块应该开放扩展的，而其原先的代码尽量封闭不可改变。</li>
</ul>
</li>
<li><p>单一职责原则（SRP）</p>
<ul>
<li>一个类应该仅有一个引起它变化的原因，变化的方向隐含着类的责任。</li>
</ul>
</li>
<li><p>Liskov替换原则（LSP)</p>
<ul>
<li>子类必须能够替换它们的基类（IS-A），继承可以表达类型抽象。</li>
</ul>
</li>
<li><p>接口隔离原则（ISP）</p>
<ul>
<li>接口应该小而完备，不该强迫用户使用多余的方法。（准确使用private&#x2F;public）。</li>
</ul>
</li>
<li><p>优先使用对象组合，而不是类继承</p>
<ul>
<li>继承通常会让子类和父类的耦合度增加，而组合的方式只要求组件具备良好定义的接口。</li>
</ul>
</li>
<li><p>封装变化点</p>
<ul>
<li>使用封装创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良影响。</li>
</ul>
</li>
<li><p>针对接口编程，而不是针对实现编程</p>
<ul>
<li>减少系统中各部分的依赖关系，从而实现“高内聚，低耦合”的类型设计方案。</li>
</ul>
</li>
</ul>
<h2 id="Singleton–单例模式"><a href="#Singleton–单例模式" class="headerlink" title="Singleton–单例模式"></a><a href="https://www.bilibili.com/video/BV1Yr4y157Ci?p=12&vd_source=65122611208f4d2dd8e86fb48f5e4e28">Singleton–单例模式</a></h2><ul>
<li><p>概念：保证一个类仅有一个实例，并提供一个该实例的全局访问点。</p>
</li>
<li><p>实现：绕过常规的构造器，提供一种机制来保证类只有一个实例。</p>
</li>
<li><p>懒汉式：用到的时候才进行初始化</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// 首先要将构造函数和拷贝操作声明为私有（绕过常规构造器），阻止编译器默认生成，且不允许外部使用。</span></span><br><span class="line">        <span class="built_in">Singleton</span>();</span><br><span class="line">        <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">        Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 声明静态变量和静态成员函数（提供外部访问接口）</span></span><br><span class="line">        <span class="comment">// 静态变量是一个堆对象，因此为指针类型，并初始化为nullptr。</span></span><br><span class="line">        <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="type">static</span> Singleton* m_instance;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::m_instance = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非线程安全版本（只适用于单线程）</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 多线程情况下，m_instance可能被创建多次。</span></span><br><span class="line">    <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>)</span><br><span class="line">        m_instance == <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程安全版本，但代价过高。当m_instance创建完成后，以后对m_instance的操作都是直接return。</span></span><br><span class="line"><span class="comment">// 即只有一次写操作（需加锁），以后都是读操作（不需加锁）。因此每次调用都加锁是没有必要的，会加大开销。</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在函数结束时，具备变量lock被析构释放（解锁）。</span></span><br><span class="line">    Lock lock;</span><br><span class="line">    <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>)</span><br><span class="line">        m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双检查锁（锁前锁后都检查），但内存读写reorder不安全，极有可能会导致双检查锁的失效。</span></span><br><span class="line"><span class="comment">// 正常情况下，m_instance = new Singleton()分为三步：</span></span><br><span class="line"><span class="comment">// 1. 先分配内存（new）2. 调用构造器初始化内存（Singleton()）3. 返回地址给m_instance</span></span><br><span class="line"><span class="comment">// 但这只是假想的顺序，到了指令级别，很有可能会出现reorder的情况：</span></span><br><span class="line"><span class="comment">// 1. 先分配内存（new）2. 返回地址给m_instance 3. 调用构造器初始化内存（Singleton()）</span></span><br><span class="line"><span class="comment">// 假设线程A执行到第2步，返回地址给m_instance，但此时尚未完成构造。</span></span><br><span class="line"><span class="comment">// 若此时线程B恰好执行，那么m_instance不为空，就直接返回m_instance。</span></span><br><span class="line"><span class="comment">// 但由于m_instance所指向的内存尚未构造，因此所获得的对象状态是不对的。</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先判空，若不空直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        Lock lock; <span class="comment">// 若为空，加锁。</span></span><br><span class="line">        <span class="comment">// 再次判空，保证线程安全。</span></span><br><span class="line">        <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>)</span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java、C#通过增加关键字volatile来告知编译器变量赋值时禁止reorder（阻止编译器优化）</span></span><br><span class="line"><span class="comment">// C++中也有volatile，但是无法跨平台使用，而C++11后提供了实现跨平台的机制。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将m_instance声明为原子对象</span></span><br><span class="line">std::atomic&lt;Singleton*&gt; Singleton::m_instance;</span><br><span class="line">std::mutex Singleton::m_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 利用原子对象的load函数获取Singleton的指针</span></span><br><span class="line">    Singleton* tmp = m_instance.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    <span class="comment">// 设置内存屏障，实现内存保护，确保tmp变量赋值时不会被reorder。</span></span><br><span class="line">    std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_acquire);</span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 依然使用双检查锁</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        tmp = m_instance.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            tmp = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">            <span class="comment">// 释放内存屏障</span></span><br><span class="line">            std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_release);</span><br><span class="line">            m_instance.<span class="built_in">store</span>(tmp, std::memory_order_relaxed); <span class="comment">// tmp再交回m_instance</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于C++11后确保了初始化静态变量是线程安全的</span></span><br><span class="line"><span class="comment">// 因为若线程执行到需初始化静态变量时，且有其他线程正初始化该变量，则阻塞当前线程</span></span><br><span class="line"><span class="comment">// 直到初始化完成，从而确保线程安全，因此单例模式可通过定义局部静态变量来简化设计。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">Singleton</span>();</span><br><span class="line">        <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">        Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 利用局部静态变量来确保只有一份实例，且初始化时线程安全</span></span><br><span class="line">            <span class="comment">// 此时不再需要动态分配内存以及指向堆变量的指针</span></span><br><span class="line">            <span class="comment">// 但每次调用getInstance时，都会检查instance是否以及初始化，即使代码中没有if-else</span></span><br><span class="line">            <span class="type">static</span> Singleton instance;</span><br><span class="line">            <span class="keyword">return</span> &amp;instance;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>饿汉式：程序启动时就完成初始化</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">Singleton</span>();</span><br><span class="line">        <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">        Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="type">static</span> Singleton* m_instance;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 启动时就完成初始化</span></span><br><span class="line">Singleton* Singleton::m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line"><span class="comment">// 无需加锁即可实现线程安全，因为此时只有读操作。</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>总结：<ul>
<li>饿汉式没有加锁，效率高，但类加载时就初始化，浪费内存。且类静态变量在不同编译单元中的初始化顺序是未定义的，若在初始化完成之前就调用<code>getInstance</code>，则会返回一个未定义的实例。</li>
<li>懒汉式第一次调用才会初始化，避免内存浪费，但为确保线程安全和效率，需实现复杂的双检查锁。</li>
<li>C++11后可用局部静态变量简化单例模式设计，因为编译器会对局部静态变量自动执行双检查锁检测，以保证线程安全。</li>
</ul>
</li>
</ul>
<h2 id="Template-Method–模板方法"><a href="#Template-Method–模板方法" class="headerlink" title="Template Method–模板方法"></a><a href="https://www.bilibili.com/video/BV1Yr4y157Ci?p=3&vd_source=65122611208f4d2dd8e86fb48f5e4e28">Template Method–模板方法</a></h2><ul>
<li><p>概念：在确定稳定操作结构（流程骨架<code>Run</code>）的前提下，灵活应对各个子步骤的变化或晚期实现需求。</p>
</li>
<li><p>实现：在父类中定义流程骨架（稳定），而将一些步骤（变化，虚函数）延迟到子类，使得子类可以复用流程骨架并重写<code>override</code>变化的步骤（早绑定-&gt;晚绑定）。</p>
</li>
<li><p>场景：<code>Library</code>开发人员：开发1、3、5三个步骤；<code>Application</code>开发人员：开发2、4两个步骤，程序主流程。（早绑定，晚期内容调用早期内容）</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 程序库开发人员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Library</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Step1</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Step3</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Step5</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 应用程序开发人员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">Step2</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">        <span class="function">boid <span class="title">Step4</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 主程序同时需要调用到两者</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Library <span class="title">lib</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Application <span class="title">app</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    lib.<span class="built_in">Step1</span>();</span><br><span class="line">    <span class="keyword">if</span> (app.<span class="built_in">Step2</span>()) &#123; lib.<span class="built_in">Step3</span>(); &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) app.<span class="built_in">Step4</span>();</span><br><span class="line">    lib.<span class="built_in">Step5</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>重构：<code>Library</code>开发人员：开发1、3、5三个步骤，同时提供程序主流程以及2、4步骤的虚函数；<code>Application</code>开发人员：开发实现2、4两个步骤。（晚绑定，早期内容调用晚期内容）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 程序库开发人员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Library</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 稳定的Template Method</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">Step1</span>();</span><br><span class="line">            <span class="comment">// Step2支持变化，虚函数的多态调用</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Step2</span>()) &#123; <span class="built_in">Step3</span>(); &#125;</span><br><span class="line">            <span class="comment">// Step4支持变化，虚函数的多态调用</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) <span class="built_in">Step4</span>();</span><br><span class="line">            <span class="built_in">Step5</span>();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Library</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Step1</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 稳定</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Step3</span><span class="params">()</span> </span>&#123;...&#125; <span class="comment">// 稳定</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Step5</span><span class="params">()</span> </span>&#123;...&#125; <span class="comment">// 稳定</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Step2</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 变化 </span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Step4</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 变化 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 应用程序开发人员（继承程序库开发人员）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> : <span class="keyword">public</span> Library &#123;</span><br><span class="line">     <span class="keyword">protected</span>:</span><br><span class="line">        <span class="comment">// 子类重写实现虚函数（变化的部分）</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Step2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Step4</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 主程序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 多态进行动态绑定：父类（程序库开发人员）指针指向子类对象（应用程序开发人员）</span></span><br><span class="line">    Library *pLib = <span class="keyword">new</span> <span class="built_in">Application</span>();</span><br><span class="line">    pLib-&gt;<span class="built_in">Run</span>();</span><br><span class="line">    <span class="keyword">delete</span> pLib;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Strategy–策略模式"><a href="#Strategy–策略模式" class="headerlink" title="Strategy–策略模式"></a><a href="https://www.bilibili.com/video/BV1Yr4y157Ci?p=4&vd_source=65122611208f4d2dd8e86fb48f5e4e28">Strategy–策略模式</a></h2><ul>
<li><p>概念：为组件提供一系列可重用的算法，从而使得类型在运行时方便地根据需要在各个算法间进行切换，可消除<code>if-else</code>条件判断或<code>switch</code>开关语句造成的耦合依赖。</p>
</li>
<li><p>实现：将一系列算法封装，使之可互相替换（变化）。使得算法独立于客户程序（稳定）而变化（扩展，子类化）。</p>
<div align="center" style=transform:scale(0.7)>
<img src="/images/策略模式.webp"/>
</div>
</li>
<li><p>场景：税率计算，先使用枚举类型列出当前支持的国家，然后使用<code>if-else</code>来根据不同的枚举值计算不同国家的税率。但随着需求变化，需要支持更多的国家，就需修改枚举定义，以及<code>if-else</code>的内容。这就违反了开放封闭原则，即应该以扩展的方式应对未来的变化，而非修改已有的代码。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">TaxBase</span> &#123;</span><br><span class="line">    CN_TAX; US_TAX;</span><br><span class="line">    DE_TAX; FR_TAX; <span class="comment">// 更改</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SalesOrder</span> &#123;</span><br><span class="line">    TaxBase tax;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">calculateTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 绝对稳定不变的情况，可用if-else，而当前则需要支持未来更多的变化，因此if-else并不合适。</span></span><br><span class="line">            <span class="comment">// 也会造成不必要的代码负担，如应用程序只在中国使用，那么其余的if-else代码永远不被执行。</span></span><br><span class="line">            <span class="comment">// 但却会被装载到代码段中，从而造成代码段过长，拖慢运行效率。</span></span><br><span class="line">            <span class="keyword">if</span> (tax == CN_TAX) &#123; ... &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tax == US_TAX) &#123; ... &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tax == DE_TAX) &#123; ... &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tax == FR_TAX) &#123; ... &#125; <span class="comment">// 更改</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>重构：设计一个策略基类（抽象基类），并将计算方法声明为纯虚函数。然后对于不同国家，都继承策略基类，并重写计算方法，以满足不同国家的计算规则。而在需要用到时，则声明一个策略基类的指针以实现多态调用。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 策略基类（抽象基类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaxStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">calculateTax</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">TatStrategy</span>() &#123;&#125; <span class="comment">// 抽象基类必须有虚析构函数，否则多态delete时会出问题。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于每个国家，都定义一个计算策略（继承于策略基类），并重写计算方法。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CNTax</span> : <span class="keyword">public</span> TatStrategy &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">calculateTax</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">USTax</span> : <span class="keyword">public</span> TatStrategy &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">calculateTax</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DETax</span> : <span class="keyword">public</span> TatStrategy &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">calculateTax</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以扩展方式应对变化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FRTax</span> : <span class="keyword">public</span> TatStrategy &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">calculateTax</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SalesOrder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        TatStrategy* strategy;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">SalesOrder</span>(StrategyFactory* strategyFactor) &#123;</span><br><span class="line">            <span class="comment">// 利用工厂模式，绕过new来生成一个对象</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;strategy = strategyFactor-&gt;<span class="built_in">createStrategy</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">SalesOrder</span>() &#123; <span class="keyword">delete</span> strategy; &#125;</span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">calculateTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 利用策略基类的指针实现多态调用，该部分是稳定的，无需更改即可支持更多的国家。</span></span><br><span class="line">            <span class="type">double</span> val = strategy-&gt;<span class="built_in">calculateTax</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Observer–观察者模式"><a href="#Observer–观察者模式" class="headerlink" title="Observer–观察者模式"></a><a href="https://www.bilibili.com/video/BV1Yr4y157Ci?p=5&spm_id_from=pageDriver&vd_source=65122611208f4d2dd8e86fb48f5e4e28">Observer–观察者模式</a></h2><ul>
<li><p>概念：定义对象间一种一对多（变化）的依赖关系，以便当一个对象（目标对象）的状态发生改变，所有依赖对象（观察者对象）都将得到通知并自动更新。观察者模式常用于设计UI框架，也是MVC模式的重要组成部分。</p>
</li>
<li><p>实现：观察者模式存在两种角色</p>
<ul>
<li>观察者：内部包含被观察者对象，当被观察对象的状态变化时，自动更新自己的状态（接收通知更新状态）。</li>
<li>被观察者：内部包含所有观察者对象，当状态变化时，通知所有观察者更新自己的状态（发送通知）。</li>
</ul>
</li>
<li><p>场景：文件分割器的进度条显示，若将文件分割器与具体的进度条控件绑定，则违反了依赖倒置原则，即抽象不应该依赖于实现细节（具体的进度条控件），从而无法满足不同平台所使用的进度条样式不同的需求。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSplitter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        string m_filePath;</span><br><span class="line">        <span class="type">int</span> m_fileNumber;</span><br><span class="line">        <span class="comment">// 此处违背了依赖倒置原则：抽象不应该依赖于实现细节</span></span><br><span class="line">        <span class="comment">// 因为实现细节会在未来发生变化，即进度样式在不同平台会有需求变更</span></span><br><span class="line">        <span class="comment">// 此时m_progressBar扮演的实际上是一个通知的角色</span></span><br><span class="line">        ProgressBar *m_progressBar; <span class="comment">// 具体的通知控件</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">FileSplitter</span>(<span class="type">const</span> string &amp;filePath, <span class="type">int</span> fileNumber, ProgressBar *progressBar)</span><br><span class="line">            : <span class="built_in">m_filePath</span>(filePath), <span class="built_in">m_fileNumber</span>(fileNumber), <span class="built_in">m_progressBar</span>(progressBar) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 读取大文件...</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_fileNumber; ++i) &#123;</span><br><span class="line">                <span class="comment">// 分批次向小文件写入...</span></span><br><span class="line">                <span class="keyword">if</span> (m_progressBar != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    m_progressBar-&gt;<span class="built_in">setValue</span>(<span class="built_in">float</span>(i+<span class="number">1</span>)/m_fileNumber) <span class="comment">// 更新进度条</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MainForm表示一个界面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainForm</span> : <span class="keyword">public</span> Form &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        TextBox* txtFilePath;</span><br><span class="line">        TextBox* txtFileNumber;</span><br><span class="line">        ProgressBar* progressBar;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">buttonClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            string filePath = txtFilePath-&gt;<span class="built_in">getText</span>();</span><br><span class="line">            <span class="type">int</span> number = <span class="built_in">atoi</span>(txtFileNumber-&gt;<span class="built_in">getText</span>().<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="function">FileSplitter <span class="title">splitter</span><span class="params">(filePath, number, progressBar)</span></span>;</span><br><span class="line">            splitter.<span class="built_in">split</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>重构：此时观察者为<code>MainForm</code>，内部包含被观察对象<code>FileSplitter</code>，并通过<code>addProgress</code>和<code>removeProgress</code>自行进行订阅管理；被观察对象为<code>FileSplitter</code>，内部以链表形式包含所有观察者对象（指针形式），并通过<code>onProgress</code>内部调用观察者对象的<code>doProgress</code>向所有观察者发出通知。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象基类，作为接口类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Progress</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doProgress</span><span class="params">(<span class="type">float</span> value)</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Progress</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileSplitter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        string m_filePath;</span><br><span class="line">        <span class="type">int</span> m_fileNumber;</span><br><span class="line">        <span class="comment">// ProgressBar *m_progressBar; // 具体的通知控件</span></span><br><span class="line">        list&lt;Progress*&gt; m_progressList; <span class="comment">// 抽象的通知机制，支持多个观察者</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">FileSplitter</span>(<span class="type">const</span> string &amp;filePath, <span class="type">int</span> fileNumber)</span><br><span class="line">            : <span class="built_in">m_filePath</span>(filePath), <span class="built_in">m_fileNumber</span>(fileNumber) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 读取大文件...</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_fileNumber; ++i) &#123;</span><br><span class="line">                <span class="comment">// 分批次向小文件写入...</span></span><br><span class="line">                <span class="built_in">onProgress</span>(<span class="built_in">float</span>(i+<span class="number">1</span>)/m_fileNumber) <span class="comment">// 更新进度条（发送通知，无需知道谁是观察者）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向容器中添加观察者，相当于Attach</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">addProgress</span><span class="params">(Progress *process)</span> </span>&#123; m_progressList.<span class="built_in">push_back</span>(process); &#125;</span><br><span class="line">        <span class="comment">// 从容器中删除观察者，相当于Detach</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">removeProgress</span><span class="params">(Progress *process)</span> </span>&#123; m_progressList.<span class="built_in">erase</span>(process); &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="comment">// 相当于Notify</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onProgress</span><span class="params">(<span class="type">float</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> iter = m_progressList.<span class="built_in">begin</span>(); iter != m_progressList.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">                (*iter)-&gt;<span class="built_in">doProgress</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MainForm表示一个界面，此处Form是主继承类，而Progress作为接口继承（抽象基类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainForm</span> : <span class="keyword">public</span> Form, <span class="keyword">public</span> Progress&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        TextBox* txtFilePath;</span><br><span class="line">        TextBox* txtFileNumber;</span><br><span class="line">        ProgressBar* progressBar;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">buttonClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            string filePath = txtFilePath-&gt;<span class="built_in">getText</span>();</span><br><span class="line">            <span class="type">int</span> number = <span class="built_in">atoi</span>(txtFileNumber-&gt;<span class="built_in">getText</span>().<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="function">FileSplitter <span class="title">splitter</span><span class="params">(filePath, number)</span></span>;</span><br><span class="line">            <span class="comment">// 传递this指针，因为此时MainForm为Progress的子类，且实现了doProgress</span></span><br><span class="line">            <span class="comment">// 观察者自行决定是否订阅通知以及订阅几个通知，目标对象（被观察者）对此一无所知</span></span><br><span class="line">            splitter.<span class="built_in">addProgress</span>(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 支持第二个观察者</span></span><br><span class="line">            ConsoleOberver cn;</span><br><span class="line">            splitter.<span class="built_in">addProgress</span>(&amp;cn);</span><br><span class="line"></span><br><span class="line">            splitter.<span class="built_in">split</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现抽象基类中的接口</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doProgress</span><span class="params">(<span class="type">float</span> value)</span> </span>&#123; progressBar-&gt;<span class="built_in">setValue</span>(value); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个观察者的具体实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConsoleOberver</span>: <span class="keyword">public</span> Progress &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doProgress</span><span class="params">(<span class="type">float</span> value)</span> </span>&#123; cout &lt;&lt; <span class="string">&#x27;.&#x27;</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>C++语法基础</title>
    <url>/2023/05/23/CPP/CPP%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="1-C和C-的区别"><a href="#1-C和C-的区别" class="headerlink" title="1. C和C++的区别"></a>1. C和C++的区别</h2><ul>
<li>C是面向过程的语言，而C++是面向对象的语言。</li>
<li>C++增加了诸如引用、类和对象、函数重载、泛型（模版）的概念。</li>
<li>在动态分配内存方面，C使用<code>malloc/free</code>函数，C++使用<code>new/delete</code>运算符。</li>
</ul>
<h2 id="2-static关键字的作用"><a href="#2-static关键字的作用" class="headerlink" title="2. static关键字的作用"></a>2. static关键字的作用</h2><ul>
<li>修饰局部变量：该变量存放在静态存储区，生命周期和整个程序的生命周期一致，在函数首次调用的时候进行初始化，函数再次调用则不会再初始化，但只有局部作用域。</li>
<li>修饰全局变量：该变量存放在静态存储区，生命周期和整个程序的生命周期一致，但具有全局作用域，声明该变量后，在整个文件中都是可见的，而在文件外不可见。</li>
<li>修饰函数：声明函数后，在整个文件中都是可见的，而在文件外不可见，可避免函数的同名冲突。</li>
<li>修饰成员变量：类的不同对象只会维持同一份拷贝，从而实现数据在同一个类的不同对象间共享，可以通过类名而不实例化对象来访问，一般不在类中而在类外初始化（不加<code>static</code>）。</li>
<li>修饰成员函数：没有<code>this</code>指针，只能访问静态成员，可以通过类名而不实例化对象来访问。</li>
</ul>
<h2 id="3-define和const的区别"><a href="#3-define和const的区别" class="headerlink" title="3. #define和const的区别"></a>3. #define和const的区别</h2><ul>
<li>编译器的处理方式不同：<code>#define</code>在预处理阶段完成代码替换；<code>const</code>则在编译阶段处理。</li>
<li>类型和安全检查不同：<code>#define</code>没有类型，不执行安全检查；<code>const</code>常量有具体类型，执行类型检查，更加安全。</li>
<li>存储的方式不同：<code>#define</code>仅通过字符串完成代码替换，编译器不会为其分配内存，存放在程序的代码段；<code>const</code>常量则会占用内存空间，存放在程序的数据段。</li>
<li>作用域不同：<code>#define</code>不受作用域限制，在定义<code>#define</code>后的所有引用都合法；<code>const</code>常量则会受到作用域的限制。</li>
</ul>
<h2 id="4-inline函数的优缺点"><a href="#4-inline函数的优缺点" class="headerlink" title="4. inline函数的优缺点"></a>4. inline函数的优缺点</h2><ul>
<li>优点：<ul>
<li><code>inline</code>函数会在函数的调用点进行代码展开，从而节省了函数调用的开销，提升了程序的效率。</li>
<li>相比于宏函数，编译器会为<code>inline</code>函数进行语法检查和类型转换，更加安全。</li>
</ul>
</li>
<li>缺点：<ul>
<li>过度使用可能会造成代码膨胀，且若<code>inline</code>函数内代码块的执行开销高于函数调用，那么程序的效率并不会得到明显改善。</li>
<li>若修改了<code>inline</code>函数的定义，则所有使用该<code>inline</code>函数的文件都需要重新编译。</li>
<li><code>inline</code>只是一条建议，是否真正内联仍取决于编译器，所以其实际行为并不可控。</li>
</ul>
</li>
</ul>
<h2 id="5-智能指针的概念、作用、分类"><a href="#5-智能指针的概念、作用、分类" class="headerlink" title="5. 智能指针的概念、作用、分类"></a>5. 智能指针的概念、作用、分类</h2><ul>
<li>智能指针是一个<code>RAII</code>类模型，其设计思想是将原生指针封装为类对象，并将<code>delete</code>操作放入析构函数中，从而利用类对象在离开作用域自动调用析构函数的机制来自动释放动态分配的内存。</li>
<li>智能指针能够处理内存泄漏和空悬指针的问题，可分为<code>auto_ptr</code>、<code>unique_ptr</code>、<code>shared_ptr</code>、<code>weak_ptr</code>四类。</li>
<li><code>auto_ptr</code>采取所有权模式，是C++98的方案，在C++11中已被弃用，主要问题在于赋值或函数传参时，对象所有权会被剥夺，存在潜在的内存崩溃的问题。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">p1</span> <span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;hello, world&quot;</span>))</span></span>;</span><br><span class="line">auto_ptr p2;</span><br><span class="line">p2 = p1; <span class="comment">// 此时p2会剥夺p1的所有权，且程序不会报错，但当要再次访问p1时会报错。</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>unique_ptr</code>是一种独占式的智能指针，即同一时间只能有一个智能指针指向同一对象，禁止拷贝构造和赋值的行为，但若源<code>unique_ptr</code>是一个临时右值，则可以允许拷贝或赋值，因为定义了移动赋值和移动构造。</li>
<li><code>shared_ptr</code>是一种共享式的智能指针，即同一时间可以有多个智能指针指向同一对象，通过引用计数机制实现。<ul>
<li><code>use_count</code>可查看资源的所有者个数</li>
<li><code>release</code>释放当前智能指针的所有权，计数减$1$</li>
<li><code>swap</code>交换两个<code>shared_ptr</code>所拥有的对象</li>
<li><code>get</code>返回内部的原生指针</li>
</ul>
</li>
<li><code>weak_ptr</code>是对对象的一种弱引用，可以绑定到<code>shared_ptr</code>上，且不会增加引用计数，从而协助<code>shared_ptr</code>工作。<code>weak_ptr</code>可以解决<code>shared_ptr</code>相互引用时的死锁问题，即两个<code>shared_ptr</code>相互引用时，两者的引用计数永远不会减为$0$，资源永远不会被释放。</li>
</ul>
<h2 id="6-shared-ptr的工作原理"><a href="#6-shared-ptr的工作原理" class="headerlink" title="6. shared_ptr的工作原理"></a>6. shared_ptr的工作原理</h2><ul>
<li>在构造函数中，引用计数初始化为$1$；在析构函数中，引用计数减$1$；在拷贝构造中，引用计数加$1$。</li>
<li>在赋值运算符中，左侧运算对象引用计数减$1$，右侧运算对象引用计数加$1$。</li>
<li>若析构函数或赋值运算符中对象的引用计数变为$0$，则通过<code>delete</code>运算符释放资源。</li>
</ul>
<h2 id="7-空悬指针和野指针"><a href="#7-空悬指针和野指针" class="headerlink" title="7. 空悬指针和野指针"></a>7. 空悬指针和野指针</h2><ul>
<li>空悬指针：释放动态分配的内存后，未及时将指针置为<code>nullptr</code>，使指针仍指向已经释放的内存地址。</li>
<li>野指针：定义指针时，未初始化。使用<code>gcc -Wall</code>编译时，会出现<code>used uninitialized</code>警告。</li>
</ul>
<h2 id="8-变量定义和变量声明的区别"><a href="#8-变量定义和变量声明的区别" class="headerlink" title="8. 变量定义和变量声明的区别"></a>8. 变量定义和变量声明的区别</h2><ul>
<li>变量定义会为变量分配地址和内存空间，而变量声明则不会；变量可以有多个声明，但只能有一个定义。</li>
<li>可以用<code>extern</code>来修饰变量声明，表示该变量的定义会出现在文件的后面部分或其他文件中。</li>
<li>使用<code>extern</code>修饰变量时，可以提供初始值，但此时就变成了定义而非声明，且该语句不能出现在函数的内部。</li>
</ul>
<h2 id="9-条件编译的作用"><a href="#9-条件编译的作用" class="headerlink" title="9. 条件编译的作用"></a>9. 条件编译的作用</h2><ul>
<li>借助条件编译，可以在需要的时候，将某些模块方便地包含进行程序中，而在不需要的时候，又能方便地屏蔽掉。</li>
<li>条件编译也可以搭配一些宏定义（如<code>NDEBUG</code>）来调试和追踪程序。</li>
</ul>
<h2 id="10-不同类型变量与“零值”比较"><a href="#10-不同类型变量与“零值”比较" class="headerlink" title="10. 不同类型变量与“零值”比较"></a>10. 不同类型变量与“零值”比较</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) &#123;...&#125; <span class="comment">// int型</span></span><br><span class="line"><span class="keyword">if</span> (flag) &#123;...&#125; <span class="comment">// bool型</span></span><br><span class="line"><span class="comment">// float型</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">equal</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(a-b) &lt; std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">epsilon</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>) &#123;...&#125; <span class="comment">// 指针型</span></span><br></pre></td></tr></table></figure>

<h2 id="11-结构体赋值"><a href="#11-结构体赋值" class="headerlink" title="11. 结构体赋值"></a>11. 结构体赋值</h2><ul>
<li>结构体在声明时就可以赋予初始值，结构体的不同对象间也可以直接赋值。</li>
<li>但当含有指针成员时，则赋值时一定要区分是深拷贝还是浅拷贝。</li>
</ul>
<h2 id="12-sizeof和strlen的区别"><a href="#12-sizeof和strlen的区别" class="headerlink" title="12. sizeof和strlen的区别"></a>12. sizeof和strlen的区别</h2><ul>
<li><code>sizeof</code>是操作符，其参数为数据类型或变量，且在编译时获得计算结果。</li>
<li><code>strlen</code>是函数，其参数只能是以<code>&#39;\0&#39;</code>字符结尾的字符串，且在程序运行时获得计算结果。</li>
<li><code>sizeof</code>的计算结果是对象所占用的内存大小（以字节为单位），而<code>strlen</code>的计算结果则是实际的字符串长度。</li>
<li>若将一个字符数组名传递给<code>sizeof</code>，不会退化成指针，但若传递给<code>strlen</code>，则会退化成指针形式。</li>
</ul>
<h2 id="13-static在C和C-中的区别"><a href="#13-static在C和C-中的区别" class="headerlink" title="13. static在C和C++中的区别"></a>13. static在C和C++中的区别</h2><ul>
<li>在C中，<code>static</code>可修饰局部变量、外部变量和函数，修饰局部变量时，可让函数在不同调用时期进行数据通信。</li>
<li>在C++中，<code>static</code>除上述功能以外，还可修饰成员变量和成员函数，从而实现同一个类的不同对象间的数据共享。</li>
</ul>
<h2 id="14-全局变量和局部变量的区别"><a href="#14-全局变量和局部变量的区别" class="headerlink" title="14. 全局变量和局部变量的区别"></a>14. 全局变量和局部变量的区别</h2><ul>
<li>全局变量具有全局作用域，生命周期从程序运行开始一直持续到程序运行结束。</li>
<li>局部变量只有局部作用域，一般在代码块或函数中定义，离开了代码块和函数就会被释放。</li>
<li>编译器和OS通过内存的分配位置来区分两者，全局变量分配在全局数据段，而局部变量则分配在堆栈中。</li>
</ul>
<h2 id="15-strcpy、sprintf、memcpy的区别"><a href="#15-strcpy、sprintf、memcpy的区别" class="headerlink" title="15. strcpy、sprintf、memcpy的区别"></a>15. strcpy、sprintf、memcpy的区别</h2><ul>
<li>三者的主要功能都是拷贝，但所操作的对象并不同。</li>
<li><code>strcpy</code>：操作对象为两个字符串，主要实现字符串的拷贝。</li>
<li><code>sprintf</code>：操作对象可以是多种数据类型，可以将多种数据以格式化的形式写入字符串。</li>
<li><code>memcpy</code>：操作对象是任意可访问的内存地址，不受类型限制，可以实现内存块间的拷贝。</li>
</ul>
<h2 id="16-指针和引用的区别"><a href="#16-指针和引用的区别" class="headerlink" title="16. 指针和引用的区别"></a>16. 指针和引用的区别</h2><ul>
<li>指针是变量，具有内存空间，而引用不是，它只是变量的别名，因此可以定义元素类型为指针的数组，但不能定义元素类型为引用的数组。</li>
<li>使用<code>sizeof</code>时，参数若为指针，则根据计算机字长返回固定大小（$32$位返回$4$，$64$位返回$8$）；参数若为引用，则返回被引用对象所占的内存大小。</li>
<li>作为函数参数时，若想通过指针改变所指对象的值，则必须解引用；而参数为引用，则可直接修改并影响原对象。</li>
<li>指针可以改变其指向，但引用不行，引用必须在定义时就通过初始化绑定到一个对象上，因此有<code>const</code>指针，但无<code>const</code>引用。</li>
<li>指针可以是多级的，但引用只能是一级。</li>
<li>对指针使用<code>++</code>运算符，则会将指针指向下一个元素位置，而对引用使用<code>++</code>运算符，则会递增被引用的对象的值。</li>
<li>动态分配内存时所返回的对象，只能使用指针接收。</li>
</ul>
<h2 id="17-typedef和-define的区别"><a href="#17-typedef和-define的区别" class="headerlink" title="17. typedef和#define的区别"></a>17. typedef和#define的区别</h2><ul>
<li>用法不同：<code>typedef</code>用于为类型起一个别名，以提高程序可读性；而<code>#define</code>一般用于定义常量或频繁使用的宏。</li>
<li>执行不同：<code>typedef</code>在编译阶段执行，具有类型检查；而<code>#define</code>在预处理阶段进行代码替换，不具备类型检查。</li>
<li>作用域不同：<code>typedef</code>具备明确的作用域；而<code>#define</code>定义后的所有引用都是合法的。</li>
<li><code>typedef</code>是一条语句，结尾要加分号；而<code>#define</code>不是语句，且不能加分号；两者定义指针时有很大的区别，如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>* int_ptr;</span><br><span class="line">int_ptr a, b; <span class="comment">// a，b均为int*</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int* int_ptr</span></span><br><span class="line">int_ptr a, b; <span class="comment">// a为int*，但b为int</span></span><br></pre></td></tr></table></figure>

<h2 id="18-指针常量和常量指针的区别"><a href="#18-指针常量和常量指针的区别" class="headerlink" title="18. 指针常量和常量指针的区别"></a>18. 指针常量和常量指针的区别</h2><ul>
<li>指针常量的意思是指针变量本身是一个常量，不可改变其指向，必须在定义时初始化，具有顶层<code>const</code>属性。</li>
<li>常量指针的意思是指针指向的是一个只读变量，不可通过指针来改变其值，具有底层<code>const</code>属性。</li>
<li>不管是指针常量还是常量指针，其最大的作用就是在修饰函数形参时，强调在函数内部实参的不可改变性。</li>
</ul>
<h2 id="19-栈区和堆区的异同"><a href="#19-栈区和堆区的异同" class="headerlink" title="19. 栈区和堆区的异同"></a>19. 栈区和堆区的异同</h2><ul>
<li>栈区和堆区并非是指堆栈这两种数据结构，而是指不同的内存存储区域。</li>
<li>栈区结构类似与栈，由编译器负责分配和释放，主要用于存放函数参数、局部变量等。</li>
<li>堆区结构类似于链表，存取顺序随意，由程序员申请内存，并负责释放，或程序结束由OS回收。</li>
</ul>
<h2 id="20-C中的结构体和C-中的区别"><a href="#20-C中的结构体和C-中的区别" class="headerlink" title="20. C中的结构体和C++中的区别"></a>20. C中的结构体和C++中的区别</h2><ul>
<li>C中结构体不能有函数成员，而C++可以。</li>
<li>C中结构体没有访问限制，而C++具有<code>private</code>、<code>public</code>、<code>protected</code>访问说明符。</li>
<li>C中结构体没有继承，而C++中具有丰富的继承体系。</li>
</ul>
<h2 id="21-避免野指针"><a href="#21-避免野指针" class="headerlink" title="21. 避免野指针"></a>21. 避免野指针</h2><ul>
<li>在定义指针变量时就将指针初始化，或置为<code>nullptr</code>。</li>
<li>在释放动态分配的内存后，将指针置为<code>nullptr</code>。</li>
<li>当一个指针指向局部变量时，在离开局部变量作用域之前将指针置为<code>nullptr</code>。</li>
</ul>
<h2 id="22-extern-quot-C-quot"><a href="#22-extern-quot-C-quot" class="headerlink" title="22. extern &quot;C&quot;"></a>22. extern &quot;C&quot;</h2><ul>
<li><code>extern &quot;C&quot;</code>是链接指示，加上<code>extern &quot;C&quot;</code>则会指示编译器对当前代码按C而不是C++的方式编译。如C++中有函数重载机制，因此在编译时，会将函数的参数类型也加入到编译后的代码中，而C没有函数重载，因此编译时，一般只包含函数名。</li>
<li>适用于多人协作开发时，一部分人擅长C，一部分人擅长C++的情况。</li>
</ul>
<h2 id="23-顶层const和底层const"><a href="#23-顶层const和底层const" class="headerlink" title="23. 顶层const和底层const"></a>23. 顶层const和底层const</h2><ul>
<li>顶层<code>const</code>是指变量本身具备不可改变的属性，必须在定义时就完成初始化。</li>
<li>底层<code>const</code>是指指针或引用所指向的对象具有不可改变的属性。</li>
</ul>
<h2 id="24-左指引用和右值引用"><a href="#24-左指引用和右值引用" class="headerlink" title="24. 左指引用和右值引用"></a>24. 左指引用和右值引用</h2><ul>
<li>左值具有持久状态，而右值要么是字面常量，要么就是表达式求值过程中创建的临时对象。</li>
<li>左值引用可以绑定到左值，常规的左值引用不能绑定到右值，但<code>const</code>左值引用可以绑定到右值上。</li>
<li>可通过<code>&amp;&amp;</code>声明右值引用类型，可绑定到字面值或一个将要销毁的对象上，而不能绑定到左值。</li>
<li>可以利用<code>std::move</code>函数显示地将一个左值转换为对应的右值引用类型。</li>
<li>右值引用常用于模板转发实参，当函数参数定义为指向模板类型参数的右值引用时，可以保持实参的所有类型信息。</li>
</ul>
<h2 id="25-volatile的作用"><a href="#25-volatile的作用" class="headerlink" title="25. volatile的作用"></a>25. volatile的作用</h2><ul>
<li><code>volatile</code>可用于修饰一个中断服务子程序会访问到的非自动变量或者是多线程间被几个任务共享的变量。</li>
<li><code>volatile</code>对象只能调用使用<code>volatile</code>修饰的成员函数，<code>volatile</code>对象也不能使用合成的拷贝&#x2F;移动构造函数和赋值运算符，若想使用，必须自定义。</li>
<li>可以用<code>const</code>和<code>volatile</code>同时修饰变量，表示变量在内部只读，只在程序外部条件变化下改变，且编译器不会优化该变量。因为<code>const</code>只是不允许程序代码修改变量，在编译期进行检查，并未实际禁止某段内存的读写特性。</li>
</ul>
<h2 id="26-静态链接和动态链接的区别"><a href="#26-静态链接和动态链接的区别" class="headerlink" title="26. 静态链接和动态链接的区别"></a>26. 静态链接和动态链接的区别</h2><ul>
<li>静态链接是指在编译链接时，直接将需要执行的代码拷贝到调用处。<ul>
<li>优点：程序发布时不需依赖库，可独立执行。</li>
<li>缺点：程序体积相对较大，若静态函数库更新，则使用此函数库的程序都要重新编译。</li>
</ul>
</li>
<li>动态链接是指在编译链接时，在程序里只有一个（指针）位置，而实际内容并不会整合到执行文件中，只有在运行时需要用到函数库功能时，程序才会去读取函数库，从而实现运行时链接。<ul>
<li>优点：多个程序可共享同一个动态库，节省资源，且函数库更新，无需重新编译使用此函数库的程序。</li>
<li>缺点：由于在运行时加载，可能会影响程序的前期执行性能。</li>
</ul>
</li>
</ul>
<h2 id="27-静态编译和动态编译"><a href="#27-静态编译和动态编译" class="headerlink" title="27. 静态编译和动态编译"></a>27. 静态编译和动态编译</h2><ul>
<li>静态编译：编译器在编译可执行文件时，把需要⽤到的对应动态链接库中的部分提取出来，连接到可执行文件中去，使可执行文件在运⾏时不需要依赖于动态链接库。</li>
<li>动态编译：可执行文件需要附带⼀个动态链接库，在执行时，需要调用其对应动态链接库的命令。其优点是缩小了可执行文件的体积，并加快了编译速度。但缺点是即使可执行文件中只用到了链接库中一两条命令，也需要附带一个相对庞大的链接库。且若其他计算机上未安装对应的运行库，则可执行文件无法运行。</li>
</ul>
<h2 id="28-定义只能在栈或堆上生成对象"><a href="#28-定义只能在栈或堆上生成对象" class="headerlink" title="28. 定义只能在栈或堆上生成对象"></a>28. 定义只能在栈或堆上生成对象</h2><ul>
<li>只在堆上生成对象：由于栈对象由编译器管理，在销毁时编译器会调用析构函数来释放对象所占用的空间，因此编译器在为类对象分配栈空间时，必须先检查类析构函数的可访问性。那么只要将析构函数声明为私有，即可阻止建立栈对象，但此时必须提供一个额外的<code>destroy</code>函数用于在类外手动销毁建立的堆对象。</li>
<li>只在栈上生成对象：在类中将<code>new</code>和<code>delete</code>重载为类的私有成员，即可阻止在类外建立堆对象。</li>
</ul>
<h2 id="29-C-中的内存分配"><a href="#29-C-中的内存分配" class="headerlink" title="29. C++中的内存分配"></a>29. C++中的内存分配</h2><ul>
<li>栈区：由编译器管理分配和回收，用于存放局部变量和函数参数。</li>
<li>堆区：由程序员管理，需使用<code>new/delete</code>手动分配和释放。空间较大，但易出现内存泄漏和内存碎片的情况。</li>
<li>全局&#x2F;静态存储区：分为初始化和未初始化两个相邻区域，用于存储初始化和未初始化的全局变量和静态变量。</li>
<li>常量存储区：用于存储常量，一般不允许修改。</li>
<li>代码区：存放程序的二进制代码。</li>
<li>局部常量存放于栈区，全局常量，编译器不分配内存，而是存放在符号表以提高访问效率，字面值常量放在常量区。</li>
</ul>
<h2 id="30-指针传递和引用传递"><a href="#30-指针传递和引用传递" class="headerlink" title="30. 指针传递和引用传递"></a>30. 指针传递和引用传递</h2><ul>
<li>指针传递本质上还是值传递，传递的是地址值，因此若是在被调函数中修改指针值，并不会影响主调函数中的指针。</li>
<li>两者作为被调函数的局部变量处理时，都会在栈中开辟内存空间，但对于指针，栈空间存放的是实参地址的副本。而对于引用，栈空间则存放实参变量的实际地址。因此，对于引用参数的处理，实际上都会通过间接寻址的方式来操作主调函数中的相关变量。</li>
</ul>
<h2 id="31-const关键字"><a href="#31-const关键字" class="headerlink" title="31. const关键字"></a>31. const关键字</h2><ul>
<li>修饰基本数据类型时，所定义的变量为常量，不可以修改其值。</li>
<li>修饰指针和引用变量，前置<code>const</code>表示具备底层<code>const</code>属性，后置<code>const</code>只用于指针，表示具备顶层<code>const</code>属性。</li>
<li>修饰函数形参时，主要强调实参在函数体内部的不可改变性。</li>
<li>修饰成员函数时，本质上会为<code>this</code>指针添加底层<code>const</code>属性，因此不能在成员函数内部修改成员变量的值。</li>
<li>修饰类对象时，常量对象只能调用常量函数，别的成员函数不能调用。</li>
</ul>
<h2 id="32-生成可执行代码的步骤"><a href="#32-生成可执行代码的步骤" class="headerlink" title="32. 生成可执行代码的步骤"></a>32. 生成可执行代码的步骤</h2><ul>
<li>预处理阶段：预处理器根据文件中#号开头的命令，修改原始程序，如<code>#include &lt;iostream&gt;</code>就是将系统中的头文件插入到程序文本中，并生成后缀为<code>.i</code>的文件。</li>
<li>编译阶段：编译器将后缀为<code>.i</code>的文件翻译成后缀为<code>.s</code>的汇编文件。</li>
<li>汇编阶段：汇编器将后缀为<code>.s</code>翻译成机器语言指令，并将这些指令打包成目标文件，即后缀为<code>.o</code>的二进制文件。</li>
<li>链接阶段：链接器将所有编译好的目标文件，以及一些库函数的目标文件合并到一起，生成最终的可执行文件。</li>
</ul>
<h2 id="33-内存泄漏场景及检测"><a href="#33-内存泄漏场景及检测" class="headerlink" title="33. 内存泄漏场景及检测"></a>33. 内存泄漏场景及检测</h2><ul>
<li>场景：在堆中创建对象，但未显示释放；在构造函数中动态申请内存，但析构函数中未释放；多态调用时，未将基类析构函数声明为虚函数。</li>
<li><code>mtrace</code>：内存追踪函数，会在每次动态申请内存的位置以及内存释放的位置记录下内存信息。只要包含头文件<code>mcheck.h</code>，并使用<code>mtrace</code>开启内存使用记录即可，且会记录到<code>MALLOC_TRACE</code>环境变量所指向的文件中。</li>
<li><code>AddressSanitizer</code>：是C&#x2F;C++内存错误检测器，可以定位内存泄漏、释放后再次使用、堆内存溢出、栈内存溢出等错误，使用方式为编译时开启<code>-fsanitize=address</code>，得到的可执行文件在运行到内存错误的地方会显示错误信息。</li>
<li>也可使用valgrind工具进行内存泄漏检测以及性能分析。</li>
</ul>
<h2 id="34-结构体内存对齐"><a href="#34-结构体内存对齐" class="headerlink" title="34. 结构体内存对齐"></a>34. 结构体内存对齐</h2><ul>
<li>内存对齐不仅可提高CPU访问内存的速度，还利用平台移植，因为某些平台遇到未进行内存对齐时会拒绝处理；而内存对齐时，会从偏移位置为$0$的位置，即第一个成员的位置，开始存储。</li>
<li>默认情况下，<code>sizeof</code>的结果是结构体中最大成员的整数倍，而各成员的首地址必定是自身大小的整数倍，不够则补齐；若定义<code>pragma pack(n)</code>，则<code>sizeof</code>的结果是<code>min(n, 结构体中最大成员的大小)</code>的整数倍，而各成员的首地址必定是<code>min(n, 自身大小)</code>的整数倍，不够则补齐。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>语法基础</tag>
      </tags>
  </entry>
</search>
